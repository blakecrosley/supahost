<!DOCTYPE html>
<!-- Use data-bs-theme="dark" to apply the dark theme across the page -->
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <title>Conway's Game of Life (Tokyo Night Edition)</title>
  <!-- Viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5.3.3 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" 
    rel="stylesheet"
  />

  <!-- Add this after Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <style>
    /* Tokyo Night colors from https://github.com/tokyo-night/tokyo-night-vscode-theme */
    :root {
      --tn-bg: #1a1b26;         /* Primary background */
      --tn-panel: #24283b;      /* Panel/secondary backgrounds */
      --tn-foreground: #c0caf5; /* Main text color */
      --tn-btn-bg: #414868;     /* Button background */
      --tn-btn-bg-hover: #565f89;
      --tn-btn-text: #c0caf5;
      --tn-border: #565f89;
    }

    /* Overall page styling */
    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--tn-bg) !important;
      color: var(--tn-foreground) !important;
      font-size: 20px;
      line-height: 1.4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Navbar inherits panel color */
    .navbar {
      background-color: var(--tn-panel) !important;
    }

    /* Buttons */
    .btn-secondary {
      background-color: var(--tn-btn-bg) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      border-color: var(--tn-border) !important;
    }

    .btn-outline-secondary {
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-outline-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }

    /* Form Controls (like .form-select) */
    .form-select {
      background-color: var(--tn-panel) !important;
      color: var(--tn-foreground) !important;
      border-color: var(--tn-border) !important;
    }
    .form-select:focus {
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(108,117,125,.5); /* or customize further */
    }

    /* Grid container */
    #grid-container {
      margin: 1em auto;
      border: 1px solid var(--tn-border);
      border-radius: 4px;
      background: var(--tn-panel);
      box-sizing: border-box;
      width: 100%;
      position: relative;
      padding-bottom: 60%;
      overflow: hidden;
    }

    /* The grid itself */
    #grid {
      display: grid;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      gap: 1px;
      background: var(--tn-border);
    }

    .cell {
      width: 100%;
      height: 100%;
      background-color: #1a1b26; /* match main background or #24283b if preferred */
      box-sizing: border-box;
    }
    .alive {
      background-color: #9ece6a; /* Vibrant green from Tokyo Night theme */
    }

    #exampleControls .btn-check:checked + .btn {
      background-color: #9ece6a !important; /* Vibrant green for active state */
      color: #1a1b26 !important;           /* Dark text for contrast */
      border-color: #9ece6a !important;
    }

    /* Increase margin top/bottom to 2em for headings and paragraphs */
    h1, h2, h3, h4, h5, h6, p {
      margin-top: 0em;
      margin-bottom: 1em;
    }
    h3 {
      color: white;
      font-weight: bold;
    }
    #exampleControls {
      margin-bottom: 2em;
    }
    #grid-container {
      margin-bottom: 2em;
    }

    /* Fix button size for Play/Pause toggle */
    #toggleBtn {
      min-width: 110px;  /* or whatever width accommodates both states */
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }
    
    /* Ensure all control buttons have consistent padding */
    .btn-group .btn {
      padding: 0.5rem 1rem;
    }
  </style>
</head>

<body>
  <!-- Bootstrap 5 Navbar -->
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <span class="navbar-brand mb-0 h1 center">Conway's Game of Life</span>
    </div>
  </nav>

  <!-- Main container: Use a Bootstrap container and row -->
  <div class="container my-4">
    <div class="row">
      <!-- 8 columns wide on large screens, 12 on smaller, with offset for center -->
      <div class="col-12 col-lg-8 offset-lg-2">
        
        <!-- BEGIN game functionality section -->
        <!-- Control buttons row -->
        <div class="row my-3">
          <div class="col-12 d-flex flex-wrap align-items-center justify-content-between">
            <!-- Button group -->
            <div class="btn-group" role="group" aria-label="Game controls">
              <button id="toggleBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-play"></i> Play
              </button>
              <button id="stepBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-skip-end"></i> Step Forward
              </button>
              <button id="randomBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-dice-6"></i> Randomize
              </button>
              <button id="clearBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-x-circle"></i> Clear
              </button>
            </div>
            <!-- Speed select -->
            <div class="ms-3">
              <select id="speedSelect" class="form-select" style="width:auto;" aria-label="Speed">
                <option value="0.5">0.5×</option>
                <option value="1.0" selected>1.0×</option>
                <option value="1.5">1.5×</option>
                <option value="2.0">2.0×</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Instructions (retaining the original text or placeholders) -->
        <div id="instructions">
          <p>
            Tap or click cells to toggle them. Press <strong>Play</strong> to start the simulation. 
            You can <strong>Step</strong> through generations manually, <strong>Random</strong> to 
            populate new cells, or <strong>Clear</strong> to wipe the board.
          </p>
        </div>

        <!-- Grid Container -->
        <div id="grid-container">
          <div id="grid"></div>
        </div>

        <!-- Pattern section -->
        <h3>Pattern Examples</h3>
        <div id="instructions">
          <p>
            These classic patterns showcase the Game's emergent behavior. The "Glider" demonstrates movement 
            across the grid, the "Pulsar" creates a mesmerizing oscillation, and the "Small Exploder" shows 
            how simple shapes can evolve into complex forms.
          </p>
        </div>
        <div id="exampleControls" class="d-flex gap-2 flex-wrap">
          <!-- Example pattern checkboxes (to be toggled in script) -->
          <div class="btn-group" role="group">
            <input type="checkbox" class="btn-check" id="gliderBtn" autocomplete="off" value="glider">
            <label class="btn btn-outline-secondary" for="gliderBtn">Glider</label>
          </div>
          <div class="btn-group" role="group">
            <input type="checkbox" class="btn-check" id="pulsarBtn" autocomplete="off" value="pulsar">
            <label class="btn btn-outline-secondary" for="pulsarBtn">Pulsar</label>
          </div>
          <div class="btn-group" role="group">
            <input type="checkbox" class="btn-check" id="smallExploderBtn" autocomplete="off" value="smallExploder">
            <label class="btn btn-outline-secondary" for="smallExploderBtn">Small Exploder</label>
          </div>
        </div>

        <!-- Editorial description -->
        <h3>About Conway's Game of Life</h3>
        <div id="description">
          <p>
            Conway's Game of Life is a classic example of how complexity can blossom from just a few 
            straightforward rules. Picture an infinite grid of cells—each one can be "on" (alive) or 
            "off" (dead). Each turn (or "generation"), every cell checks how many neighbors are alive. 
            If it's overcrowded, it dies. If it’s too lonely, it also dies. But with exactly three 
            neighbors, a dead cell will spark into life.
          </p>
          <p>
            This simple set of rules leads to endlessly fascinating behavior—from stable formations 
            and repeating oscillators, to self-propagating "spaceships" that traverse the grid. 
            It's a perfect demonstration of how complexity can arise from simplicity, and it's even 
            Turing complete, meaning it can, in theory, simulate any computation.
          </p>
        </div>
        <!-- END game functionality section -->
      
      </div>
    </div>
  </div>

  <!-- Bootstrap 5.3.3 JS (includes Popper) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous">
  </script>

  <!-- Conway's Game of Life Script (Vanilla JS) -->
  <script>
    // -----------------------------------------------------
    // Configuration: Patterns, Gameplay
    // -----------------------------------------------------
    const patterns = {
      glider: [
        [0, 1],
        [1, 2],
        [2, 0],
        [2, 1],
        [2, 2],
      ],
      pulsar: [
        // Top
        [-4, -2], [-4, -1], [-4, 0], [-4, 1], [-4, 2],
        // Bottom
        [4, -2], [4, -1], [4, 0], [4, 1], [4, 2],
        // Left
        [-2, -4], [-1, -4], [0, -4], [1, -4], [2, -4],
        // Right
        [-2, 4], [-1, 4], [0, 4], [1, 4], [2, 4],
        // Inner vertical bars
        [-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2],
        [-2, 2],  [-1, 2],  [0, 2],  [1, 2],  [2, 2],
        // Inner horizontal bars
        [-2, -1], [-2, 0], [-2, 1],
        [2, -1],  [2, 0],  [2, 1],
      ],
      smallExploder: [
        [0, 0],
        [1, -1], [1, 0], [1, 1],
        [2, -1],         [2, 1],
        [3, 0],
      ],
    };

    let rows = 30;
    let cols = 50;
    let grid = [];
    let playing = false;
    let timer = null;
    let baseInterval = 200; // ms
    let currentSpeedMultiplier = 1.0;

    // On load, run initialization
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize the grid size
      calculateGridDimensions();
      // Create the grid
      grid = createEmptyGrid(rows, cols);
      buildGridUI();

      // Attach event handlers
      document.getElementById("toggleBtn").addEventListener("click", toggleGame);
      document.getElementById("stepBtn").addEventListener("click", stepGeneration);
      document.getElementById("randomBtn").addEventListener("click", randomizeGrid);
      document.getElementById("clearBtn").addEventListener("click", clearGrid);

      document.getElementById("speedSelect").addEventListener("change", (e) => {
        currentSpeedMultiplier = parseFloat(e.target.value);
        if (playing) {
          stopGame();
          startGame();
        }
      });

      // Pattern checkboxes
      ["gliderBtn", "pulsarBtn", "smallExploderBtn"].forEach((btnId) => {
        const btnElem = document.getElementById(btnId);
        btnElem?.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          if (isChecked) {
            // Uncheck other patterns
            ["gliderBtn", "pulsarBtn", "smallExploderBtn"]
              .filter((otherId) => otherId !== btnId)
              .forEach((otherId) => {
                document.getElementById(otherId).checked = false;
              });

            // Load and auto-play the selected pattern
            loadPattern(e.target.value);
          } else {
            // Stop game if user unchecks current pattern
            stopGame();
            document.getElementById("toggleBtn").textContent = "Play";
          }
        });
      });

      // Handle window resize with debounce
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          const dims = calculateGridDimensions();
          if (dims.rows !== rows || dims.cols !== cols) {
            rows = dims.rows;
            cols = dims.cols;
            grid = createEmptyGrid(rows, cols);
            buildGridUI();
          }
        }, 250);
      });
    });

    // -----------------------------------------------------
    // Grid Setup
    // -----------------------------------------------------
    function calculateGridDimensions() {
      const containerElem = document.getElementById("grid-container");
      // We won't change rows & cols dynamically for this example,
      // but if we did, we could measure containerElem.clientWidth & .clientHeight
      rows = 30;
      cols = 50;
      return { rows, cols };
    }

    function createEmptyGrid(r, c) {
      const arr = [];
      for (let i = 0; i < r; i++) {
        arr[i] = [];
        for (let j = 0; j < c; j++) {
          arr[i][j] = 0;
        }
      }
      return arr;
    }

    function buildGridUI() {
      const gridElem = document.getElementById("grid");
      gridElem.innerHTML = "";
      gridElem.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      gridElem.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cellDiv = document.createElement("div");
          cellDiv.classList.add("cell");
          cellDiv.dataset.row = String(r);
          cellDiv.dataset.col = String(c);

          // Toggle cell on click
          cellDiv.addEventListener("click", () => {
            grid[r][c] = grid[r][c] ? 0 : 1;
            renderGrid();
          });

          gridElem.appendChild(cellDiv);
        }
      }
      renderGrid();
    }

    // -----------------------------------------------------
    // Rendering
    // -----------------------------------------------------
    function renderGrid() {
      const allCells = document.querySelectorAll("#grid .cell");
      allCells.forEach((cellDiv) => {
        const r = parseInt(cellDiv.dataset.row);
        const c = parseInt(cellDiv.dataset.col);
        cellDiv.classList.toggle("alive", grid[r][c] === 1);
      });
    }

    // -----------------------------------------------------
    // Game Logic
    // -----------------------------------------------------
    function computeNextGeneration(currentGrid) {
      const newGrid = createEmptyGrid(rows, cols);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const neighbors = countNeighbors(currentGrid, r, c);
          const cellState = currentGrid[r][c];
          // Conway's rules
          if (cellState === 1) {
            // Live cell
            newGrid[r][c] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else {
            // Dead cell
            newGrid[r][c] = (neighbors === 3) ? 1 : 0;
          }
        }
      }
      return newGrid;
    }

    function countNeighbors(g, row, col) {
      let count = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue; // skip itself
          const nr = row + dr;
          const nc = col + dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            count += g[nr][nc];
          }
        }
      }
      return count;
    }

    function allCellsDead(g) {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] === 1) return false;
        }
      }
      return true;
    }

    // -----------------------------------------------------
    // Pattern Loading
    // -----------------------------------------------------
    function loadPattern(patternName) {
      if (!patterns[patternName]) return;
      stopGame();

      // Clear grid first
      grid = createEmptyGrid(rows, cols);

      // Calculate bounding box of pattern
      const pattern = patterns[patternName];
      let minRow = Infinity, maxRow = -Infinity;
      let minCol = Infinity, maxCol = -Infinity;
      pattern.forEach(([r, c]) => {
        if (r < minRow) minRow = r;
        if (r > maxRow) maxRow = r;
        if (c < minCol) minCol = c;
        if (c > maxCol) maxCol = c;
      });

      const patternHeight = maxRow - minRow + 1;
      const patternWidth = maxCol - minCol + 1;
      const rowOffset = Math.floor(rows / 2 - patternHeight / 2) - minRow;
      const colOffset = Math.floor(cols / 2 - patternWidth / 2) - minCol;

      // Populate the grid
      pattern.forEach(([r, c]) => {
        const newR = r + rowOffset;
        const newC = c + colOffset;
        if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
          grid[newR][newC] = 1;
        }
      });

      // Force a full redraw
      renderGrid();

      // Start playing automatically
      startGame();
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> Pause';
    }

    // -----------------------------------------------------
    // Controls
    // -----------------------------------------------------
    function startGame() {
      if (allCellsDead(grid)) {
        randomizeGrid();
      }
      if (!playing) {
        playing = true;
        timer = setInterval(() => {
          const nextGen = computeNextGeneration(grid);
          grid = nextGen;
          renderGrid();
        }, calculateInterval());
      }
    }

    function stopGame() {
      playing = false;
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-play"></i> Play';
    }

    function toggleGame() {
      if (playing) {
        stopGame();
      } else {
        startGame();
        document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> Pause';
      }
    }

    function stepGeneration() {
      stopGame();
      grid = computeNextGeneration(grid);
      renderGrid();
    }

    function randomizeGrid() {
      stopGame();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          grid[r][c] = Math.random() > 0.8 ? 1 : 0;
        }
      }
      renderGrid();
    }

    function clearGrid() {
      stopGame();
      grid = createEmptyGrid(rows, cols);
      renderGrid();
    }

    function calculateInterval() {
      // 1.0 speed = 200 ms
      return baseInterval / currentSpeedMultiplier;
    }
  </script>

  <!-- cite original Tokyo Night reference in markdown, as requested -->
  <p style="display:none;">
    Referenced from [Tokyo Night VSCode Theme](https://github.com/tokyo-night/tokyo-night-vscode-theme)
  </p>
</body>
</html>
