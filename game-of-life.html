<!DOCTYPE html>
<!-- Use data-bs-theme="dark" to apply the dark theme across the page -->
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <title>Conway's Game of Life (Tokyo Night Edition)</title>
  <!-- Viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5.3.3 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" 
    rel="stylesheet"
  />

  <!-- Add this after Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <style>
    /* Tokyo Night colors from https://github.com/tokyo-night/tokyo-night-vscode-theme */
    :root {
      --tn-bg: #1a1b26;         /* Primary background */
      --tn-panel: #24283b;      /* Panel/secondary backgrounds */
      --tn-foreground: #c0caf5; /* Main text color */
      --tn-btn-bg: #414868;     /* Button background */
      --tn-btn-bg-hover: #565f89;
      --tn-btn-text: #c0caf5;
      --tn-border: #565f89;
    }

    /* Overall page styling */
    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--tn-bg) !important;
      color: var(--tn-foreground) !important;
      font-size: 20px;
      line-height: 1.4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Navbar inherits panel color */
    .navbar {
      background-color: var(--tn-panel) !important;
    }

    /* Buttons */
    .btn-secondary {
      background-color: var(--tn-btn-bg) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      border-color: var(--tn-border) !important;
    }

    .btn-outline-secondary {
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-outline-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }

    /* Form Controls (like .form-select) */
    .form-select {
      background-color: var(--tn-panel) !important;
      color: var(--tn-foreground) !important;
      border-color: var(--tn-border) !important;
    }
    .form-select:focus {
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(108,117,125,.5); /* or customize further */
    }

    /* Grid container */
    #grid-container {
      margin: 0 auto;
      border: 1px solid var(--tn-border);
      border-radius: .5rem;
      background: var(--tn-panel);
      box-sizing: border-box;
      width: 100%;
      position: relative;
      padding-bottom: 60%;
      overflow: hidden;
    }

    #zoomControls {
      margin: 16px 0;
    }

    /* Control buttons row spacing */
    #gameControls {
      margin-bottom: 16px;
    }

    /* The container that we transform for zooming */
    #gridWrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-origin: top left;
      pointer-events: none; /* This allows pointer events to pass through to #grid */
    }

    #grid {
      display: grid;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      gap: 0;
      background: var(--tn-border);
      pointer-events: all;  /* We receive pointer events here, ignoring the parent’s scale */
    }

    .cell {
      width: 100%;
      height: 100%;
      background-color: #24283b; /* match main background or #24283b if preferred */
      box-sizing: border-box;
    }
    .alive {
      background-color: #88f9d7; /* Vibrant green from Tokyo Night theme */
    }

    #exampleControls .btn-check:checked + .btn {
      background-color: #88f9d7 !important; /* Vibrant green for active state */
      color: #1a1b26 !important;           /* Dark text for contrast */
      border-color: #88f9d7 !important;
    }

    /* Increase margin top/bottom to 2em for headings and paragraphs */
    h1, h2, h3, h4, h5, h6  {
      margin-top: 0em;
      margin-bottom: .5em;
    }
    p {
      margin-bottom: 1em;
    }
    p.mb-large {
      margin-bottom: 3em;
    }
    h1, h3 {
      color: white;
      font-weight: bold;
    }
    #exampleControls {
      margin-bottom: 2em;
    }

    /* Ensure all control buttons have consistent padding */
    .btn-group .btn {
      padding: 0.5rem 1rem;
    }

    .footer {
      background-color: var(--tn-panel);
      border-top: 1px solid var(--tn-border);
      position: relative;
      bottom: 0;
      width: 100%;
    }
    
    .text-muted {
      color: var(--tn-foreground) !important;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <!-- Bootstrap 5 Navbar -->
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <span class="navbar-brand mb-0 h1"></span>
      <a href="https://x.com/BlakeC" class="navbar-text me-3 text-decoration-none" target="_blank">
        <img src="./assets/profile.jpg" 
             alt="@blakec" 
             class="rounded-circle me-2" 
             style="width: 32px; height: 32px;">
        <i class="bi bi-twitter-x"></i> @blakec
      </a>
      </span>
      <div class="ms-auto">
        <a href="https://blakecrosley.com" class="btn btn-outline-secondary me-2" target="_blank">
          blakecrosley.com
        </a>
        <a href="https://941apps.com" class="btn btn-outline-secondary" target="_blank">
          941apps.com
        </a>
      </div>
    </div>
  </nav>

  <!-- Main container: Use a Bootstrap container and row -->
  <div class="container my-4">
    <div class="row">
      <!-- 8 columns wide on large screens, 12 on smaller, with offset for center -->
      <div class="col-12 col-lg-8 offset-lg-2">
        
        <!-- BEGIN game functionality section -->
        <!-- Control buttons row -->
        <div class="row" id="gameControls">
          <div class="col-12 d-flex flex-wrap align-items-center justify-content-between">
            <h1>Conway's Game of Life</h1>

          <!-- Instructions (retaining the original text or placeholders) -->
          <div id="instructions">
            <p class="mb-large">
              <strong>Select</strong> any area to create clusters of cells, or <strong>select and drag</strong> 
              to draw living paths. Press <strong>Play</strong> to watch your creation evolve, or use <strong>Step Forward</strong> 
              to advance one generation at a time. Use <strong>Randomize</strong> for chaos, 
              or <strong>Clear</strong> to start fresh.
            </p>
          </div>            

            <!-- Button group -->
            <div class="btn-group btn-group-lg" role="group" aria-label="Game controls">
              <button id="toggleBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>
              </button>
              <button id="stepBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-skip-end"></i> <span class="d-none d-sm-inline">Step Forward</span>
              </button>
              <button id="randomBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-dice-6"></i> <span class="d-none d-sm-inline">Randomize</span>
              </button>
              <button id="clearBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-x-circle"></i> <span class="d-none d-sm-inline">Clear</span>
              </button>
            </div>
            <!-- Speed select -->
            <div class="ms-3 d-inline-flex align-items-center">
              <label for="speedSelect" class="form-label me-2 mb-0">Speed</label>
              <select id="speedSelect" class="form-select form-select-lg" style="width:auto;" aria-label="Speed">
                <option value="0.5">0.5×</option>
                <option value="1.0" selected>1.0×</option>
                <option value="1.5">1.5×</option>
                <option value="2.0">2.0×</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Grid Container -->
        <div id="grid-container">
          <div id="gridWrapper">
            <div id="grid"></div>
          </div>
        </div>

        <!-- Zoom controls -->
        <div class="d-flex justify-content-end align-items-center" id="zoomControls">
          <label for="zoomSelect" class="form-label me-2 mb-0">Zoom</label>
          <select id="zoomSelect" class="form-select form-select-lg d-inline-block" style="width:auto;">
            <option value="1" selected>1×</option>
            <option value="2">2×</option>
            <option value="3">3×</option>
          </select>
        </div>

        <!-- Pattern section -->
        <h3>Pattern Examples</h3>
        <div id="instructions">
          <p>
            These classic patterns showcase the Game's emergent behavior. The "Glider" demonstrates movement 
            across the grid, the "Pulsar" creates a mesmerizing oscillation, and the "Small Exploder" shows 
            how simple shapes can evolve into complex forms.
          </p>
        </div>
        <div id="exampleControls" class="d-flex gap-2 flex-wrap mb-large">
          <!-- Example pattern checkboxes (to be toggled in script) -->
          <div class="btn-group" role="group">
            <input type="checkbox" class="btn-check" id="gliderBtn" autocomplete="off" value="glider">
            <label class="btn btn-outline-secondary" for="gliderBtn">Glider</label>
          </div>
          <div class="btn-group" role="group">
            <input type="checkbox" class="btn-check" id="pulsarBtn" autocomplete="off" value="pulsar">
            <label class="btn btn-outline-secondary" for="pulsarBtn">Pulsar</label>
          </div>
          <div class="btn-group" role="group">
            <input type="checkbox" class="btn-check" id="smallExploderBtn" autocomplete="off" value="smallExploder">
            <label class="btn btn-outline-secondary" for="smallExploderBtn">Small Exploder</label>
          </div>
        </div>

        <!-- Editorial description -->
        <h3>About Conway's Game of Life</h3>
        <div id="description">
          <p>
            Conway's Game of Life is a classic example of how complexity can blossom from just a few 
            straightforward rules. Picture an infinite grid of cells—each one can be "on" (alive) or 
            "off" (dead). Each turn (or "generation"), every cell checks how many neighbors are alive. 
            If it's overcrowded, it dies. If it's too lonely, it also dies. But with exactly three 
            neighbors, a dead cell will spark into life.
          </p>
          <p>
            This simple set of rules leads to endlessly fascinating behavior—from stable formations 
            and repeating oscillators, to self-propagating "spaceships" that traverse the grid. 
            It's a perfect demonstration of how complexity can arise from simplicity, and it's even 
            Turing complete, meaning it can, in theory, simulate any computation.
          </p>
        </div>

        <!-- Code Showcase -->
        <h3>The Algorithm</h3>
        <p>At its heart, the Game of Life runs on just a few elegant functions that determine life and death in our cellular universe:</p>
        
        <div class="code-showcase" style="background: #1a1b26; border-radius: .5rem; padding: 1.5rem; margin: 1rem 0 3rem 0;">
          <!-- Core Algorithm -->
          <pre style="background: #24283b; padding: 1.5rem; border-radius: .3rem; overflow-x: auto;"><code>
<span style="color: #565f89;">// The core algorithm that determines life and death</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">computeNextGeneration</span>(<span style="color: #e0af68;">currentGrid</span>) {
  <span style="color: #c0caf5;">const newGrid = createEmptyGrid(rows, cols);</span>
  
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> r = <span style="color: #ff9e64;">0</span>; r < rows; r++) {
    <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> c = <span style="color: #ff9e64;">0</span>; c < cols; c++) {
      <span style="color: #c0caf5;">const neighbors = countNeighbors(currentGrid, r, c);</span>
      <span style="color: #c0caf5;">const cellState = currentGrid[r][c];</span>

      <span style="color: #565f89;">// Apply Conway's rules of life</span>
      <span style="color: #bb9af7;">if</span> (cellState === <span style="color: #ff9e64;">1</span>) {
        <span style="color: #565f89;">// Live cell survives if it has 2 or 3 neighbors</span>
        newGrid[r][c] = (neighbors === <span style="color: #ff9e64;">2</span> || neighbors === <span style="color: #ff9e64;">3</span>) ? <span style="color: #ff9e64;">1</span> : <span style="color: #ff9e64;">0</span>;
      } <span style="color: #bb9af7;">else</span> {
        <span style="color: #565f89;">// Dead cell springs to life if it has exactly 3 neighbors</span>
        newGrid[r][c] = (neighbors === <span style="color: #ff9e64;">3</span>) ? <span style="color: #ff9e64;">1</span> : <span style="color: #ff9e64;">0</span>;
      }
    }
  }
  <span style="color: #bb9af7;">return</span> newGrid;
}</code></pre>

          <p style="color: #c0caf5; padding: 1rem 0;">
            The core algorithm applies Conway's rules to each cell in the grid. For each generation, it checks every cell's 
            state and its neighbor count to determine if it lives, dies, or springs to life. This creates the mesmerizing 
            patterns we see evolving on the board.
          </p>

          <!-- Neighbor Counting -->
          <pre style="background: #24283b; padding: 1.5rem; border-radius: .3rem; margin-top: 1rem; overflow-x: auto;"><code>
<span style="color: #565f89;">// Count live neighbors for each cell</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">countNeighbors</span>(<span style="color: #e0af68;">g</span>, <span style="color: #e0af68;">row</span>, <span style="color: #e0af68;">col</span>) {
  <span style="color: #c0caf5;">let count = 0;</span>
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> dr = -<span style="color: #ff9e64;">1</span>; dr <= <span style="color: #ff9e64;">1</span>; dr++) {
    <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> dc = -<span style="color: #ff9e64;">1</span>; dc <= <span style="color: #ff9e64;">1</span>; dc++) {
      <span style="color: #bb9af7;">if</span> (dr === <span style="color: #ff9e64;">0</span> && dc === <span style="color: #ff9e64;">0</span>) <span style="color: #bb9af7;">continue</span>; <span style="color: #565f89;">// skip itself</span>
      <span style="color: #c0caf5;">const nr = row + dr;</span>
      <span style="color: #c0caf5;">const nc = col + dc;</span>
      <span style="color: #bb9af7;">if</span> (nr >= <span style="color: #ff9e64;">0</span> && nr < rows && nc >= <span style="color: #ff9e64;">0</span> && nc < cols) {
        count += g[nr][nc];
      }
    }
  }
  <span style="color: #bb9af7;">return</span> count;
}</code></pre>

          <p style="color: #c0caf5; padding: 1rem 0;">
            The neighbor counting function scans the eight cells surrounding each position. It carefully handles edge cases 
            and provides the vital information needed to apply Conway's rules. This efficient implementation uses simple 
            addition since living cells are represented as 1's and dead cells as 0's.
          </p>

          <!-- Pattern Loading -->
          <pre style="background: #24283b; padding: 1.5rem; border-radius: .3rem; margin-top: 1rem; overflow-x: auto;"><code>
<span style="color: #565f89;">// Load and center a predefined pattern on the grid</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">loadPattern</span>(<span style="color: #e0af68;">patternName</span>) {
  <span style="color: #bb9af7;">if</span> (!patterns[patternName]) <span style="color: #bb9af7;">return</span>;
  
  <span style="color: #565f89;">// Calculate pattern dimensions</span>
  <span style="color: #c0caf5;">const pattern = patterns[patternName];</span>
  <span style="color: #c0caf5;">const bounds = calculatePatternBounds(pattern);</span>
  
  <span style="color: #565f89;">// Center the pattern</span>
  <span style="color: #c0caf5;">const rowOffset = Math.floor(rows / 2 - bounds.height / 2);</span>
  <span style="color: #c0caf5;">const colOffset = Math.floor(cols / 2 - bounds.width / 2);</span>
  
  <span style="color: #565f89;">// Place the pattern on the grid</span>
  pattern.forEach(([r, c]) => {
    <span style="color: #c0caf5;">const newR = r + rowOffset;</span>
    <span style="color: #c0caf5;">const newC = c + colOffset;</span>
    <span style="color: #bb9af7;">if</span> (isValidCell(newR, newC)) {
      grid[newR][newC] = <span style="color: #ff9e64;">1</span>;
    }
  });
}</code></pre>

          <p style="color: #c0caf5; padding: 1rem 0;">
            Pattern loading is what allows us to place predefined structures onto the grid. It automatically centers the pattern 
            and ensures it fits within the boundaries. This function transforms the simple coordinate lists below into living 
            cells on our grid.
          </p>

          <!-- Pattern Definitions -->
          <pre style="background: #24283b; padding: 1.5rem; border-radius: .3rem; margin-top: 1rem; overflow-x: auto;"><code>
<span style="color: #565f89;">// Classic patterns that demonstrate emergent behavior</span>
<span style="color: #bb9af7;">const</span> <span style="color: #7aa2f7;">patterns</span> = {
  <span style="color: #565f89;">// Glider - Moves diagonally across the grid indefinitely</span>
  <span style="color: #7aa2f7;">glider</span>: [
    [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">1</span>],                     <span style="color: #565f89;">// Top</span>
    [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>],                     <span style="color: #565f89;">// Middle</span>
    [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>]    <span style="color: #565f89;">// Bottom</span>
  ],

  <span style="color: #565f89;">// Pulsar - Large symmetric oscillator with period 3</span>
  <span style="color: #7aa2f7;">pulsar</span>: [
    <span style="color: #565f89;">// Outer frame</span>
    [-<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">1</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">0</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">1</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">2</span>],
    [<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">2</span>],
    <span style="color: #565f89;">// Inner structure</span>
    [-<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">4</span>], [-<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">0</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">4</span>],
    [-<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">4</span>], [-<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">4</span>],
    [-<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">0</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">2</span>],
    [-<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>]
  ],

  <span style="color: #565f89;">// Small Exploder - Rapidly expands into chaotic patterns</span>
  <span style="color: #7aa2f7;">smallExploder</span>: [
    [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">0</span>],                     <span style="color: #565f89;">// Core</span>
    [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">1</span>],    <span style="color: #565f89;">// Center</span>
    [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">1</span>],         <span style="color: #565f89;">// Sides</span>
    [<span style="color: #ff9e64;">3</span>, <span style="color: #ff9e64;">0</span>]                      <span style="color: #565f89;">// Tail</span>
  ]
};</code></pre>

          <p style="color: #c0caf5; padding: 1rem 0;">
            These pattern definitions encode classic Game of Life structures using coordinate pairs. Each pattern demonstrates 
            different emergent behaviors: the Glider moves endlessly across the grid, the Pulsar oscillates in place, and 
            the Small Exploder creates expanding chaos from a tiny seed.
          </p>
        </div>

        <!-- END game functionality section -->
      
      </div>
    </div>
  </div>

  <!-- Bootstrap 5.3.3 JS (includes Popper) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous">
  </script>

  <!-- Conway's Game of Life Script (Vanilla JS) -->
  <script>
    // -----------------------------------------------------
    // Configuration: Patterns, Gameplay
    // -----------------------------------------------------
    const patterns = {
      glider: [
        [0, 1],
        [1, 2],
        [2, 0],
        [2, 1],
        [2, 2],
      ],
      pulsar: [
        // Top
        [-4, -2], [-4, -1], [-4, 0], [-4, 1], [-4, 2],
        // Bottom
        [4, -2], [4, -1], [4, 0], [4, 1], [4, 2],
        // Left
        [-2, -4], [-1, -4], [0, -4], [1, -4], [2, -4],
        // Right
        [-2, 4], [-1, 4], [0, 4], [1, 4], [2, 4],
        // Inner vertical bars
        [-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2],
        [-2, 2],  [-1, 2],  [0, 2],  [1, 2],  [2, 2],
        // Inner horizontal bars
        [-2, -1], [-2, 0], [-2, 1],
        [2, -1],  [2, 0],  [2, 1],
      ],
      smallExploder: [
        [0, 0],
        [1, -1], [1, 0], [1, 1],
        [2, -1],         [2, 1],
        [3, 0],
      ],
    };

    let baseRows = 30;
    let baseCols = 50;
    let rows = baseRows;
    let cols = baseCols;
    let grid = [];
    let playing = false;
    let timer = null;
    let baseInterval = 200; // ms
    let currentSpeedMultiplier = 1.0;
    let currentZoom = 1.0;

    // On load, run initialization
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize the grid size
      calculateGridDimensions();
      // Create the grid
      grid = createEmptyGrid(rows, cols);
      buildGridUI();

      // Attach event handlers
      document.getElementById("toggleBtn").addEventListener("click", toggleGame);
      document.getElementById("stepBtn").addEventListener("click", stepGeneration);
      document.getElementById("randomBtn").addEventListener("click", randomizeGrid);
      document.getElementById("clearBtn").addEventListener("click", clearGrid);

      document.getElementById("speedSelect").addEventListener("change", (e) => {
        currentSpeedMultiplier = parseFloat(e.target.value);
        if (playing) {
          // Clear existing interval
          if (timer) {
            clearInterval(timer);
            timer = null;
          }
          // Start new interval with updated speed
          timer = setInterval(() => {
            grid = computeNextGeneration(grid);
            renderGrid();
          }, calculateInterval());
        }
      });

      // Pattern checkboxes
      ["gliderBtn", "pulsarBtn", "smallExploderBtn"].forEach((btnId) => {
        const btnElem = document.getElementById(btnId);
        btnElem?.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          if (isChecked) {
            // Uncheck other patterns
            ["gliderBtn", "pulsarBtn", "smallExploderBtn"]
              .filter((otherId) => otherId !== btnId)
              .forEach((otherId) => {
                document.getElementById(otherId).checked = false;
              });

            // Load and auto-play the selected pattern
            loadPattern(e.target.value);
          } else {
            // Stop game if user unchecks current pattern
            stopGame();
            document.getElementById("toggleBtn").textContent = "Play";
          }
        });
      });

      // Handle window resize with debounce
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          const dims = calculateGridDimensions();
          if (dims.rows !== rows || dims.cols !== cols) {
            rows = dims.rows;
            cols = dims.cols;
            grid = createEmptyGrid(rows, cols);
            buildGridUI();
          }
        }, 250);
      });

      // Listen for zoom changes
      const zoomSelect = document.getElementById("zoomSelect");
      zoomSelect.addEventListener("change", (e) => {
        if (!playing) {
          setZoom(parseFloat(e.target.value));
        }
      });
    });

    // -----------------------------------------------------
    // Grid Setup
    // -----------------------------------------------------
    function calculateGridDimensions() {
      const containerElem = document.getElementById("grid-container");
      // We won't change rows & cols dynamically for this example,
      // but if we did, we could measure containerElem.clientWidth & .clientHeight
      rows = 30;
      cols = 50;
      return { rows, cols };
    }

    function createEmptyGrid(r, c) {
      const arr = [];
      for (let i = 0; i < r; i++) {
        arr[i] = [];
        for (let j = 0; j < c; j++) {
          arr[i][j] = 0;
        }
      }
      return arr;
    }

    function buildGridUI() {
      const gridElem = document.getElementById("grid");
      gridElem.innerHTML = "";
      gridElem.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      gridElem.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

      let isMouseDown = false;
      let lastCell = null;

      // Add mouse event listeners to the grid container
      gridElem.addEventListener('mousedown', (e) => { isMouseDown = true; });
      gridElem.addEventListener('mouseup', () => { 
        isMouseDown = false;
        lastCell = null;
      });
      gridElem.addEventListener('mouseleave', () => { 
        isMouseDown = false;
        lastCell = null;
      });

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cellDiv = document.createElement("div");
          cellDiv.classList.add("cell");
          cellDiv.dataset.row = String(r);
          cellDiv.dataset.col = String(c);

          // Handle both click and drag
          cellDiv.addEventListener("mousedown", (e) => {
            e.preventDefault(); // Prevent text selection
            createClump(r, c);
            renderGrid();
          });

          cellDiv.addEventListener("mouseenter", () => {
            if (isMouseDown && lastCell !== `${r},${c}`) {
              lastCell = `${r},${c}`;
              grid[r][c] = 1;
              renderGrid();
            }
          });

          gridElem.appendChild(cellDiv);
        }
      }
      renderGrid();
    }

    // Create a random clump of live cells around the clicked point
    function createClump(centerR, centerC) {
      const radius = 2;
      for (let dr = -radius; dr <= radius; dr++) {
        for (let dc = -radius; dc <= radius; dc++) {
          const r = centerR + dr;
          const c = centerC + dc;
          if (r >= 0 && r < rows && c >= 0 && c < cols) {
            // Random chance of cell being alive, higher chance closer to center
            const distance = Math.sqrt(dr * dr + dc * dc);
            const probability = 0.8 - (distance / radius) * 0.5;
            grid[r][c] = Math.random() < probability ? 1 : 0;
          }
        }
      }
    }

    // -----------------------------------------------------
    // Rendering
    // -----------------------------------------------------
    function renderGrid() {
      const allCells = document.querySelectorAll("#grid .cell");
      allCells.forEach((cellDiv) => {
        const r = parseInt(cellDiv.dataset.row);
        const c = parseInt(cellDiv.dataset.col);
        cellDiv.classList.toggle("alive", grid[r][c] === 1);
      });
    }

    // -----------------------------------------------------
    // Game Logic
    // -----------------------------------------------------
    function computeNextGeneration(currentGrid) {
      const newGrid = createEmptyGrid(rows, cols);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const neighbors = countNeighbors(currentGrid, r, c);
          const cellState = currentGrid[r][c];
          // Conway's rules
          if (cellState === 1) {
            // Live cell
            newGrid[r][c] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else {
            // Dead cell
            newGrid[r][c] = (neighbors === 3) ? 1 : 0;
          }
        }
      }
      return newGrid;
    }

    function countNeighbors(g, row, col) {
      let count = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue; // skip itself
          const nr = row + dr;
          const nc = col + dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            count += g[nr][nc];
          }
        }
      }
      return count;
    }

    function allCellsDead(g) {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] === 1) return false;
        }
      }
      return true;
    }

    // -----------------------------------------------------
    // Pattern Loading
    // -----------------------------------------------------
    function loadPattern(patternName) {
      if (!patterns[patternName]) return;
      stopGame();

      // Clear grid first
      grid = createEmptyGrid(rows, cols);

      // Calculate bounding box of pattern
      const pattern = patterns[patternName];
      let minRow = Infinity, maxRow = -Infinity;
      let minCol = Infinity, maxCol = -Infinity;
      pattern.forEach(([r, c]) => {
        if (r < minRow) minRow = r;
        if (r > maxRow) maxRow = r;
        if (c < minCol) minCol = c;
        if (c > maxCol) maxCol = c;
      });

      const patternHeight = maxRow - minRow + 1;
      const patternWidth = maxCol - minCol + 1;
      const rowOffset = Math.floor(rows / 2 - patternHeight / 2) - minRow;
      const colOffset = Math.floor(cols / 2 - patternWidth / 2) - minCol;

      // Populate the grid
      pattern.forEach(([r, c]) => {
        const newR = r + rowOffset;
        const newC = c + colOffset;
        if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
          grid[newR][newC] = 1;
        }
      });

      // Force a full redraw
      renderGrid();

      // Start playing automatically
      startGame();
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';
    }

    // -----------------------------------------------------
    // Controls
    // -----------------------------------------------------
    function startGame() {
      // Stop any existing game loop
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      
      // If grid is completely empty, randomize it
      if (allCellsDead(grid)) {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            grid[r][c] = Math.random() > 0.8 ? 1 : 0;
          }
        }
        renderGrid();
      }
      
      // Start the game loop
      playing = true;
      timer = setInterval(() => {
        grid = computeNextGeneration(grid);
        renderGrid();
      }, calculateInterval());

      // Disable zoom dropdown while playing
      document.getElementById("zoomSelect").disabled = true;
    }

    function stopGame() {
      playing = false;
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>';

      // Re-enable zoom dropdown
      document.getElementById("zoomSelect").disabled = false;
    }

    function toggleGame() {
      if (playing) {
        stopGame();
      } else {
        startGame();
        document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';
      }
    }

    function stepGeneration() {
      stopGame();
      grid = computeNextGeneration(grid);
      renderGrid();
    }

    function randomizeGrid() {
      stopGame();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          grid[r][c] = Math.random() > 0.8 ? 1 : 0;
        }
      }
      renderGrid();
    }

    function clearGrid() {
      stopGame();
      grid = createEmptyGrid(rows, cols);
      renderGrid();
    }

    function calculateInterval() {
      // 1.0 speed = 200 ms
      return baseInterval / currentSpeedMultiplier;
    }

    function setZoom(zoomValue) {
      if (playing) return; // Don’t allow zoom changes while game is running

      // Store old grid so we can copy it
      const oldGrid = grid;
      const oldRows = rows;
      const oldCols = cols;

      // Multiply rows & cols by the chosen zoom value
      rows = Math.floor(baseRows * zoomValue);
      cols = Math.floor(baseCols * zoomValue);

      // Create a new empty grid
      const newGrid = createEmptyGrid(rows, cols);

      // Center the old data inside the new grid
      const rowOffset = Math.floor((rows - oldRows) / 2);
      const colOffset = Math.floor((cols - oldCols) / 2);

      for (let r = 0; r < oldRows; r++) {
        for (let c = 0; c < oldCols; c++) {
          const newR = r + rowOffset;
          const newC = c + colOffset;
          // If the new cell indices are valid, copy old data
          if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
            newGrid[newR][newC] = oldGrid[r][c];
          }
        }
      }

      // Update our global grid with the new one
      grid = newGrid;

      // Rebuild the UI so we see the new number of squares
      buildGridUI();
    }
  </script>

  <!-- cite original Tokyo Night reference in markdown, as requested -->
  <p style="display:none;">
    Referenced from [Tokyo Night VSCode Theme](https://github.com/tokyo-night/tokyo-night-vscode-theme)
  </p>

  <!-- Footer -->
  <footer class="footer mt-auto py-3">
    <div class="container text-center">
      <span class="text-muted">© 2024 blakecrosley.com. All rights reserved.</span>
    </div>
  </footer>
</body>
</html>
