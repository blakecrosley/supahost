<!DOCTYPE html>
<!-- Use data-bs-theme="dark" to apply the dark theme across the page -->
<html lang="en" data-bs-theme="dark">
<head>
  <!-- Google tag (gtag.js) -->
  <script>
    // Initialize dataLayer before gtag loads
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    
    // Configure before loading gtag.js
    gtag('js', new Date());
    gtag('config', 'G-4JE9G63Y9Z', {
      'send_page_view': true,
      'transport_type': 'beacon'
    });
  </script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4JE9G63Y9Z"></script>
  <meta charset="UTF-8" />
  <title>Conway's Game of Life - Blake Crosley Sandbox</title>
  <!-- Viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5.3.3 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" 
    rel="stylesheet"
  />

  <!-- Add this after Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <style>
    /* Tokyo Night colors from https://github.com/tokyo-night/tokyo-night-vscode-theme */
    :root {
      --tn-bg: #1a1b26;         /* Primary background */
      --tn-panel: #24283b;      /* Panel/secondary backgrounds */
      --tn-foreground: #c0caf5; /* Main text color */
      --tn-btn-bg: #414868;     /* Button background */
      --tn-btn-bg-hover: #565f89;
      --tn-btn-text: #c0caf5;
      --tn-border: #565f89;
    }

    /* Overall page styling */
    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--tn-bg) !important;
      color: var(--tn-foreground) !important;
      font-size: 20px;
      line-height: 1.4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding-top: 120px;
      padding-bottom: 0px;
    }

    /* Navbar inherits panel color */
    .navbar {
      background-color: rgba(36, 40, 59, 0.8) !important;
      border-bottom: 1px solid var(--tn-border);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Buttons */
    .btn-secondary {
      background-color: var(--tn-btn-bg) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      border-color: var(--tn-border) !important;
    }

    .btn-outline-secondary {
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-outline-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }

    /* Form Controls (like .form-select) */
    .form-select {
      background-color: var(--tn-panel) !important;
      color: var(--tn-foreground) !important;
      border-color: var(--tn-border) !important;
    }
    .form-select:focus {
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(108,117,125,.5); /* or customize further */
    }

    /* Grid container */
    #grid-container {
      margin: 0 auto;
      border: 1px solid var(--tn-border);
      border-radius: .5rem;
      background: var(--tn-panel);
      box-sizing: border-box;
      width: 100%;
      position: relative;
      padding-bottom: 60%;
      overflow: hidden;
      cursor: crosshair;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #zoomControls {
      margin: 16px 0;
    }

    /* Control buttons row spacing */
    #gameControls {
      margin-bottom: 16px;
    }

    /* The container that we transform for zooming */
    #gridWrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #grid {
      display: grid;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      gap: 0;
      background: var(--tn-border);
      cursor: crosshair;
    }

    .cell {
      width: 100%;
      height: 100%;
      background-color: #24283b; /* match main background or #24283b if preferred */
      box-sizing: border-box;
      cursor: crosshair;
    }
    .alive {
      background-color: #88f9d7; /* Vibrant green from Tokyo Night theme */
    }

    #exampleControls .btn-check:checked + .btn {
      background-color: #88f9d7 !important; /* Vibrant green for active state */
      color: #1a1b26 !important;           /* Dark text for contrast */
      border-color: #88f9d7 !important;
    }

    /* Increase margin top/bottom to 2em for headings and paragraphs */
    h1, h2, h3, h4, h5, h6  {
      margin-top: 0em;
      margin-bottom: .5em;
      color: rgb(245, 133, 237);
      font-weight: bold;
    }

    /* Link styling using the heading color */
    a.instructions-link {
      color: rgb(245, 133, 237);
      text-decoration: underline;
      transition: all 0.2s ease;
    }
    
    a.instructions-link:hover {
      color: rgb(250, 164, 244);
      text-decoration: underline;
      text-underline-offset: 4px;
    }
    
    a.instructions-link:active {
      color: rgb(219, 119, 212);
    }

    p {
      margin-bottom: 1em;
    }
    p.mb-large {
      margin-bottom: 3em;
    }
    #exampleControls {
      margin-bottom: 2em;
    }

    /* Ensure all control buttons have consistent padding */
    .btn-group .btn {
      padding: 0.5rem 1rem;
    }

    .footer {
      background-color: var(--tn-panel);
      border-top: 1px solid var(--tn-border);
      position: relative;
      bottom: 0;
      width: 100%;
      padding: 1rem 0;
    }
    
    .text-muted {
      color: var(--tn-foreground) !important;
      opacity: 0.7;
    }

    .footer-links a {
      color: var(--tn-foreground);
      opacity: 0.7;
      text-decoration: none;
      margin: 0.5rem;
      transition: opacity 0.2s ease;
    }

    .footer-links a:hover {
      opacity: 1;
    }

    /* Modal styling */
    .modal-content {
      background: var(--tn-panel);
      border: 1px solid var(--tn-border);
    }
    
    .modal-header {
      border-bottom-color: var(--tn-border);
    }
    
    .modal-dialog-game {
      max-width: 66.666667%;
    }

    .cell:active,
    .cell.dragging {
      cursor: cell;
    }

    @media (hover: none) and (pointer: coarse) {
      #grid-container {
        -webkit-overflow-scrolling: touch;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      #gridWrapper {
        transform-origin: center center;
        -webkit-transform-origin: center center;
        will-change: transform;
      }

      #grid {
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      .cell {
        /* Remove min-width/height constraints - let the grid system handle it */
        min-width: initial;
        min-height: initial;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        touch-action: none;
      }
    }

    /* Specific iOS fixes */
    @supports (-webkit-touch-callout: none) {
      #grid-container {
        position: relative;
        z-index: 1;
      }
      
      #gridWrapper {
        position: absolute;
        width: 100%;
        height: 100%;
        transform-style: flat;
        -webkit-transform-style: flat;
      }
    }

    .form-select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #loadingState {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--tn-panel);
      border-radius: .5rem;
      z-index: 10;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 1rem;
    }

    .spinner {
      width: 3rem;
      height: 3rem;
      border: 0.25rem solid var(--tn-border);
      border-top-color: var(--tn-foreground);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #grid-container {
      position: relative; /* Ensure this is set */
    }

    /* Fade transition classes */
    .fade-out {
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .fade-in {
      opacity: 1;
      transition: opacity 0.2s ease-in;
    }

    /* Add to your existing styles */
    .navbar-toggler {
      border-color: var(--tn-border);
      padding: 0.25rem 0.5rem;
    }

    .navbar-toggler:focus {
      box-shadow: none;
      border-color: var(--tn-foreground);
    }

    .navbar-toggler .bi-list {
      font-size: 1.5rem;
    }

    /* Mobile-specific navbar styles */
    @media (max-width: 991.98px) {
      .navbar .navbar-collapse {
        padding: 1rem 0;
      }
      
      .navbar .navbar-nav {
        gap: 0.5rem;
      }
      
      .navbar .btn {
        width: 100%;
        margin: 0 !important;
      }
    }

    /* Mobile footer styles */
    @media (max-width: 768px) {
      .footer {
        margin: 0;
        padding: 1rem 0;
      }

      .footer .container {
        padding: 0;
        margin: 0;
        max-width: 100%;
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }

      .footer-links {
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }
      
      .footer-social {
        justify-content: center;
        margin: 0.5rem 0;
      }
      
      .footer-links a {
        margin: 0.5rem;
      }
    }

    .footer-container {
      padding: 0;
      margin: 0;
    }

    /* Footer base styles */
    .footer-links {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .footer-social {
      display: flex;
      gap: 1.5rem;
    }

    /* Mobile footer styles */
    @media (max-width: 768px) {
      .footer {
        margin: 0;
        padding: 1rem 0;
      }

      .footer .container {
        padding: 0;
        margin: 0;
        max-width: 100%;
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .footer-links {
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }
      
      .footer-social {
        justify-content: center;
        margin: 0.5rem 0;
      }
    }
  </style>

  <link rel="icon" type="image/png" href="../../../favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="../../../favicon/favicon.svg" />
  <link rel="shortcut icon" href="../../../favicon/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png" />
  <link rel="manifest" href="../../../favicon/site.webmanifest" />

</head>

<body>
  <!-- Bootstrap 5 Navbar -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a href="https://x.com/BlakeC" class="navbar-brand text-decoration-none" target="_blank">
        <img src="../../../assets/profile.jpg" 
             alt="@blakec" 
             class="rounded-circle me-2" 
             style="width: 32px; height: 32px;">
        @blakec
      </a>
      
      <!-- Hamburger button for mobile -->
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" 
              data-bs-target="#navbarContent" aria-controls="navbarContent" 
              aria-expanded="false" aria-label="Toggle navigation">
        <i class="bi bi-list text-light"></i>
      </button>
      
      <!-- Collapsible content -->
      <div class="collapse navbar-collapse" id="navbarContent">
        <div class="navbar-nav ms-auto">
          <a href="https://blakecrosley.com" class="btn btn-outline-secondary me-2" target="_blank">
            blakecrosley.com
          </a>
          <a href="https://941apps.com" class="btn btn-outline-secondary" target="_blank">
            941apps.com
          </a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Main container: Use a Bootstrap container and row -->
  <div class="container-fluid">
    <div class="row">
      <!-- 8 columns wide on large screens, 12 on smaller, with offset for center -->
      <div class="col-12 col-lg-8 offset-lg-2">
        
        <!-- BEGIN game functionality section -->
        <!-- Control buttons row -->
        <div class="row" id="gameControls">
          <div class="col-12 d-flex flex-wrap align-items-center justify-content-between">
            <h1>Conway's Game of Life</h1>

            <!-- Editorial description -->
            <div id="description">
              <p>
                Conway's Game of Life is a classic example of how complexity can blossom from just a few 
                straightforward rules. Picture an infinite grid of cells—each one can be "on" (alive) or 
                "off" (dead). Each turn (or "generation"), every cell checks how many neighbors are alive. 
                If it's overcrowded, it dies. If it's too lonely, it also dies. But with exactly three 
                neighbors, a dead cell will spark into life.
              </p>
              <p>
                This simple set of rules leads to endlessly fascinating behavior—from stable formations 
                and repeating oscillators, to self-propagating "spaceships" that traverse the grid. 
                It's a perfect demonstration of how complexity can arise from simplicity, and it's even 
                Turing complete, meaning it can, in theory, simulate any computation.
              </p>
              <p class="mb-large">
                <a href="#" class="instructions-link" data-bs-toggle="modal" data-bs-target="#instructionsModal">
                  How it works
                </a>
              </p>
  </div>

            <!-- Button group -->
            <div class="btn-group btn-group-lg" role="group" aria-label="Game controls">
              <button id="toggleBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>
              </button>
              <button id="stepBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-skip-end"></i> <span class="d-none d-sm-inline">Step Forward</span>
              </button>
              <button id="randomBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-dice-6"></i> <span class="d-none d-sm-inline">Randomize</span>
              </button>
              <button id="clearBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-x-circle"></i> <span class="d-none d-sm-inline">Clear</span>
              </button>
            </div>
            <!-- Speed select -->
            <div class="ms-3 d-inline-flex align-items-center">
              <label for="speedSelect" class="form-label me-2 mb-0">Speed</label>
              <select id="speedSelect" class="form-select form-select-lg" style="width:auto;" aria-label="Speed">
        <option value="0.5">0.5×</option>
        <option value="1.0" selected>1.0×</option>
        <option value="1.5">1.5×</option>
        <option value="2.0">2.0×</option>
      </select>
    </div>
    </div>    
    </div>

    <!-- Grid Container -->
    <div id="grid-container">
      <div id="loadingState">
        <div class="spinner"></div>
        <div>Loading game board...</div>
      </div>
      <div id="gridWrapper">
        <div id="grid"></div>
      </div>
    </div>

    <!-- Zoom controls -->
    <div class="d-flex justify-content-end align-items-center" id="zoomControls">
      <label for="zoomSelect" class="form-label me-2 mb-0">Zoom</label>
      <select id="zoomSelect" class="form-select form-select-lg d-inline-block" style="width:auto;">
        <option value="1" selected>1×</option>
        <option value="2">2×</option>
        <option value="3">3×</option>
      </select>
    </div>

    <!-- Pattern section -->
    <h3>Pattern Examples</h3>
    <div id="instructions">
      <p>
        These classic patterns showcase the Game's emergent behavior. The "Glider" demonstrates movement 
        across the grid, the "Pulsar" creates a mesmerizing oscillation, and the "Small Exploder" shows 
        how simple shapes can evolve into complex forms.
      </p>
    </div>
    <div id="exampleControls" class="d-flex gap-2 flex-wrap mb-large">
      <!-- Example pattern checkboxes (to be toggled in script) -->
      <div class="btn-group" role="group">
        <input type="checkbox" class="btn-check" id="gliderBtn" autocomplete="off" value="glider">
        <label class="btn btn-outline-secondary" for="gliderBtn">Glider</label>
      </div>
      <div class="btn-group" role="group">
        <input type="checkbox" class="btn-check" id="pulsarBtn" autocomplete="off" value="pulsar">
        <label class="btn btn-outline-secondary" for="pulsarBtn">Pulsar</label>
      </div>
      <div class="btn-group" role="group">
        <input type="checkbox" class="btn-check" id="smallExploderBtn" autocomplete="off" value="smallExploder">
        <label class="btn btn-outline-secondary" for="smallExploderBtn">Small Exploder</label>
      </div>
    </div>

    <!-- Code Showcase -->
    <h3>The Algorithm</h3>
    <p>At its heart, the Game of Life runs on just a few elegant functions that determine life and death in our cellular universe:</p>
    
    <div class="code-showcase" style="background: #1a1b26; border-radius: .5rem; margin: 1rem 0 3rem 0;">
      <!-- Core Algorithm -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; overflow-x: auto; margin: 0; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// The core algorithm that determines life and death</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">computeNextGeneration</span>(<span style="color: #e0af68;">currentGrid</span>) {
  <span style="color: #c0caf5;">const newGrid = createEmptyGrid(rows, cols);</span>
  
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> r = <span style="color: #ff9e64;">0</span>; r < rows; r++) {
    <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> c = <span style="color: #ff9e64;">0</span>; c < cols; c++) {
      <span style="color: #c0caf5;">const neighbors = countNeighbors(currentGrid, r, c);</span>
      <span style="color: #c0caf5;">const cellState = currentGrid[r][c];</span>

      <span style="color: #565f89;">// Apply Conway's rules of life</span>
      <span style="color: #bb9af7;">if</span> (cellState === <span style="color: #ff9e64;">1</span>) {
        <span style="color: #565f89;">// Live cell survives if it has 2 or 3 neighbors</span>
        newGrid[r][c] = (neighbors === <span style="color: #ff9e64;">2</span> || neighbors === <span style="color: #ff9e64;">3</span>) ? <span style="color: #ff9e64;">1</span> : <span style="color: #ff9e64;">0</span>;
      } <span style="color: #bb9af7;">else</span> {
        <span style="color: #565f89;">// Dead cell springs to life if it has exactly 3 neighbors</span>
        newGrid[r][c] = (neighbors === <span style="color: #ff9e64;">3</span>) ? <span style="color: #ff9e64;">1</span> : <span style="color: #ff9e64;">0</span>;
      }
    }
  }
  <span style="color: #bb9af7;">return</span> newGrid;
}</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        The core algorithm applies Conway's rules to each cell in the grid. For each generation, it checks every cell's 
        state and its neighbor count to determine if it lives, dies, or springs to life. This creates the mesmerizing 
        patterns we see evolving on the board.
      </p>

      <!-- Neighbor Counting -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; margin-bottom: 0; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Count live neighbors for each cell</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">countNeighbors</span>(<span style="color: #e0af68;">g</span>, <span style="color: #e0af68;">row</span>, <span style="color: #e0af68;">col</span>) {
  <span style="color: #c0caf5;">let count = 0;</span>
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> dr = -<span style="color: #ff9e64;">1</span>; dr <= <span style="color: #ff9e64;">1</span>; dr++) {
    <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> dc = -<span style="color: #ff9e64;">1</span>; dc <= <span style="color: #ff9e64;">1</span>; dc++) {
      <span style="color: #bb9af7;">if</span> (dr === <span style="color: #ff9e64;">0</span> && dc === <span style="color: #ff9e64;">0</span>) <span style="color: #bb9af7;">continue</span>; <span style="color: #565f89;">// skip itself</span>
      <span style="color: #c0caf5;">const nr = row + dr;</span>
      <span style="color: #c0caf5;">const nc = col + dc;</span>
      <span style="color: #bb9af7;">if</span> (nr >= <span style="color: #ff9e64;">0</span> && nr < rows && nc >= <span style="color: #ff9e64;">0</span> && nc < cols) {
        count += g[nr][nc];
      }
    }
  }
  <span style="color: #bb9af7;">return</span> count;
}</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        The neighbor counting function scans the eight cells surrounding each position. It carefully handles edge cases 
        and provides the vital information needed to apply Conway's rules. This efficient implementation uses simple 
        addition since living cells are represented as 1's and dead cells as 0's.
      </p>

      <!-- Pattern Loading -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Load and center a predefined pattern on the grid</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">loadPattern</span>(<span style="color: #e0af68;">patternName</span>) {
  <span style="color: #bb9af7;">if</span> (!patterns[patternName]) <span style="color: #bb9af7;">return</span>;
  
  <span style="color: #565f89;">// Calculate pattern dimensions</span>
  <span style="color: #c0caf5;">const pattern = patterns[patternName];</span>
  <span style="color: #c0caf5;">const bounds = calculatePatternBounds(pattern);</span>
  
  <span style="color: #565f89;">// Center the pattern</span>
  <span style="color: #c0caf5;">const rowOffset = Math.floor(rows / 2 - bounds.height / 2);</span>
  <span style="color: #c0caf5;">const colOffset = Math.floor(cols / 2 - bounds.width / 2);</span>
  
  <span style="color: #565f89;">// Place the pattern on the grid</span>
  pattern.forEach(([r, c]) => {
    <span style="color: #c0caf5;">const newR = r + rowOffset;</span>
    <span style="color: #c0caf5;">const newC = c + colOffset;</span>
    <span style="color: #bb9af7;">if</span> (isValidCell(newR, newC)) {
      grid[newR][newC] = <span style="color: #ff9e64;">1</span>;
    }
  });
}</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        Pattern loading is what allows us to place predefined structures onto the grid. It automatically centers the pattern 
        and ensures it fits within the boundaries. This function transforms the simple coordinate lists below into living 
        cells on our grid.
      </p>

      <!-- Pattern Definitions -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Classic patterns that demonstrate emergent behavior</span>
<span style="color: #bb9af7;">const</span> <span style="color: #7aa2f7;">patterns</span> = {
  <span style="color: #565f89;">// Glider - Moves diagonally across the grid indefinitely</span>
  <span style="color: #7aa2f7;">glider</span>: [
    [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">1</span>],                     <span style="color: #565f89;">// Top</span>
    [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>],                     <span style="color: #565f89;">// Middle</span>
    [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>]      <span style="color: #565f89;">// Bottom</span>
  ],

  <span style="color: #565f89;">// Pulsar - Large symmetric oscillator with period 3</span>
  <span style="color: #7aa2f7;">pulsar</span>: [
    <span style="color: #565f89;">// Outer frame</span>
    [-<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">1</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">0</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">1</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">2</span>],
    [<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">2</span>],
    <span style="color: #565f89;">// Inner structure</span>
    [-<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">4</span>], [-<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">0</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">4</span>],
    [-<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">4</span>], [-<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">4</span>],
    [-<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">0</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">2</span>],
    [-<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>]
  ],

  <span style="color: #565f89;">// Small Exploder - Rapidly expands into chaotic patterns</span>
  <span style="color: #7aa2f7;">smallExploder</span>: [
    [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">0</span>],                     <span style="color: #565f89;">// Core</span>
    [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">1</span>],    <span style="color: #565f89;">// Center</span>
    [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">1</span>],            <span style="color: #565f89;">// Sides</span>
    [<span style="color: #ff9e64;">3</span>, <span style="color: #ff9e64;">0</span>]                      <span style="color: #565f89;">// Tail</span>
  ]
};</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        These pattern definitions encode classic Game of Life structures using coordinate pairs. Each pattern demonstrates 
        different emergent behaviors: the Glider moves endlessly across the grid, the Pulsar oscillates in place, and 
        the Small Exploder creates expanding chaos from a tiny seed.
      </p>
    </div>

    <!-- END game functionality section -->
  
  </div>
  </div>
  <!-- Footer -->
  <div class="container-fluid footer-container">
    <div class="row">
      <footer class="footer mt-auto">
        <div class="container d-flex justify-content-between align-items-center">
          <span class="text-muted">© 2025</span>
          <div class="footer-links">
            <div class="">
              <a href="https://x.com/BlakeC" target="_blank" title="X (Twitter)">
                <i class="bi bi-twitter-x"></i>
              </a>
              <a href="https://github.com/blakecrosley" target="_blank" title="GitHub">
                <i class="bi bi-github"></i>
              </a>
            </div>
            <a href="https://blakecrosley.com" target="_blank" title="Personal Website">
              blakecrosley.com
            </a>
            <a href="https://941apps.com" target="_blank" title="941 Apps">
              941apps.com
            </a>
          </div>
        </div>
      </footer>
    </div>
  </div>


  <!-- Bootstrap 5.3.3 JS (includes Popper) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous">
  </script>

  <!-- Conway's Game of Life Script (Vanilla JS) -->
  <script>
    // -----------------------------------------------------
    // Configuration: Patterns, Gameplay
    // -----------------------------------------------------
    const patterns = {
      glider: [
        [0, 1],
        [1, 2],
        [2, 0],
        [2, 1],
        [2, 2],
      ],
      pulsar: [
        // Top
        [-4, -2], [-4, -1], [-4, 0], [-4, 1], [-4, 2],
        // Bottom
        [4, -2], [4, -1], [4, 0], [4, 1], [4, 2],
        // Left
        [-2, -4], [-1, -4], [0, -4], [1, -4], [2, -4],
        // Right
        [-2, 4], [-1, 4], [0, 4], [1, 4], [2, 4],
        // Inner vertical bars
        [-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2],
        [-2, 2],  [-1, 2],  [0, 2],  [1, 2],  [2, 2],
        // Inner horizontal bars
        [-2, -1], [-2, 0], [-2, 1],
        [2, -1],  [2, 0],  [2, 1],
      ],
      smallExploder: [
        [0, 0],
        [1, -1], [1, 0], [1, 1],
        [2, -1],         [2, 1],
        [3, 0],
      ],
    };

    let baseRows = 30;
    let baseCols = 50;
    let rows = baseRows;
    let cols = baseCols;
    let grid = createEmptyGrid(rows, cols);
    let playing = false;
    let timer = null;
    let baseInterval = 200; // ms
    let currentSpeedMultiplier = 1.0;
    let currentZoom = 1.0;

    // Add at the top of the script
    const DOM = {
      grid: document.getElementById('grid'),
      toggleBtn: document.getElementById('toggleBtn'),
      speedSelect: document.getElementById('speedSelect'),
      zoomSelect: document.getElementById('zoomSelect')
    };

    // On load, run initialization
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize the grid size
      calculateGridDimensions();
      // Create the grid
      grid = createEmptyGrid(rows, cols);
      buildGridUI();

      // Attach event handlers
      document.getElementById("toggleBtn").addEventListener("click", toggleGame);
      document.getElementById("stepBtn").addEventListener("click", stepGeneration);
      document.getElementById("randomBtn").addEventListener("click", randomizeGrid);
      document.getElementById("clearBtn").addEventListener("click", clearGrid);

      document.getElementById("speedSelect").addEventListener("change", (e) => {
        currentSpeedMultiplier = parseFloat(e.target.value);
        if (playing) {
          // Clear existing interval
          if (timer) {
            clearInterval(timer);
            timer = null;
          }
          // Start new interval with updated speed
          timer = setInterval(() => {
            grid = computeNextGeneration(grid);
            renderGrid();
          }, calculateInterval());
        }
      });

      // Pattern checkboxes
      ["gliderBtn", "pulsarBtn", "smallExploderBtn"].forEach((btnId) => {
        const btnElem = document.getElementById(btnId);
        btnElem?.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          if (isChecked) {
            // Uncheck other patterns
            ["gliderBtn", "pulsarBtn", "smallExploderBtn"]
              .filter((otherId) => otherId !== btnId)
              .forEach((otherId) => {
                document.getElementById(otherId).checked = false;
              });

            // Load and auto-play the selected pattern
            loadPattern(e.target.value);
          } else {
            // Stop game if user unchecks current pattern
            stopGame();
            document.getElementById("toggleBtn").textContent = "Play";
          }
        });
      });

      // Handle window resize with debounce
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          const dims = calculateGridDimensions();
          if (dims.rows !== rows || dims.cols !== cols) {
            rows = dims.rows;
            cols = dims.cols;
            grid = createEmptyGrid(rows, cols);
            buildGridUI();
          }
        }, 250);
      });

      // Listen for zoom changes
      const zoomSelect = document.getElementById("zoomSelect");
      zoomSelect.addEventListener("change", (e) => {
        if (!playing) {
          setZoom(parseFloat(e.target.value));
        }
      });
    });

    // -----------------------------------------------------
    // Grid Setup
    // -----------------------------------------------------
    function calculateGridDimensions() {
      const containerElem = document.getElementById("grid-container");
      // We won't change rows & cols dynamically for this example,
      // but if we did, we could measure containerElem.clientWidth & .clientHeight
      rows = 30;
      cols = 50;
      return { rows, cols };
    }

    // Pre-allocate neighbor offset arrays for performance
    const NEIGHBOR_OFFSETS = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];

    function createEmptyGrid(r, c) {
      const arr = [];
      for (let i = 0; i < r; i++) {
        arr[i] = [];
        for (let j = 0; j < c; j++) {
          arr[i][j] = 0;
        }
      }
      return arr;
    }

    function showLoading() {
      const loadingState = document.getElementById('loadingState');
      const gridWrapper = document.getElementById('gridWrapper');
      
      // Fade out grid
      gridWrapper.classList.add('fade-out');
      
      // Show loading state with fade in
      loadingState.style.display = 'flex';
      // Force reflow
      void loadingState.offsetWidth;
      loadingState.classList.add('fade-in');
    }

    function hideLoading() {
      const loadingState = document.getElementById('loadingState');
      const gridWrapper = document.getElementById('gridWrapper');
      
      // Fade in grid
      gridWrapper.classList.remove('fade-out');
      
      // Hide loading state
      loadingState.classList.remove('fade-in');
      setTimeout(() => {
        loadingState.style.display = 'none';
      }, 200); // Match transition duration
    }

    async function setZoom(zoomValue) {
      if (playing) return;

      showLoading();

      try {
        // Store old grid state
        const oldGrid = grid;
        const oldRows = rows;
        const oldCols = cols;

        // Update dimensions
        rows = Math.floor(baseRows * zoomValue);
        cols = Math.floor(baseCols * zoomValue);

        const newGrid = createEmptyGrid(rows, cols);
        const rowOffset = Math.floor((rows - oldRows) / 2);
        const colOffset = Math.floor((cols - oldCols) / 2);

        // Copy existing pattern
        for (let r = 0; r < oldRows; r++) {
          for (let c = 0; c < oldCols; c++) {
            const newR = r + rowOffset;
            const newC = c + colOffset;
            if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
              newGrid[newR][newC] = oldGrid[r][c];
            }
          }
        }

        grid = newGrid;

        // Remove transform-based zoom
        const gridWrapper = document.getElementById('gridWrapper');
        gridWrapper.style.transform = '';
        
        // Build the grid UI
        await buildGridUI();

        // Hide loading after everything is done
        hideLoading();
      } catch (error) {
        console.error('Error during zoom:', error);
        hideLoading();
      }
    }

    function buildGridUI() {
      const gridElem = document.getElementById("grid");
      
      // Clear and set up grid
      gridElem.innerHTML = "";
      gridElem.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      gridElem.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

      // Create cells in batches
      const fragment = document.createDocumentFragment();
      const batchSize = 100;
      let cellsCreated = 0;

      return new Promise(resolve => {
        function createNextBatch() {
          const startCell = cellsCreated;
          const endCell = Math.min(cellsCreated + batchSize, rows * cols);
          
          for (let i = startCell; i < endCell; i++) {
            const r = Math.floor(i / cols);
            const c = i % cols;
            
            const cellDiv = document.createElement("div");
            cellDiv.className = "cell";
            cellDiv.dataset.row = String(r);
            cellDiv.dataset.col = String(c);
            
            fragment.appendChild(cellDiv);
          }
          
          cellsCreated = endCell;
          
          if (cellsCreated < rows * cols) {
            requestAnimationFrame(createNextBatch);
          } else {
            gridElem.appendChild(fragment);
            
            // Add touch handlers to grid container after cells are created
            setupTouchHandlers(gridElem);
            setupMouseHandlers(gridElem);
            
            renderGrid();
            resolve();
          }
        }
        
        createNextBatch();
      });
    }

    // Separate touch handler setup
    function setupTouchHandlers(gridElem) {
      let isInteracting = false;
      let lastCell = null;
      let lastTouch = null;
      let hasMoved = false;  // Add this to track if touch has moved

      gridElem.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isInteracting = true;
        hasMoved = false;  // Reset movement flag
        const touch = e.touches[0];
        lastTouch = touch;
        const cellElem = document.elementFromPoint(touch.clientX, touch.clientY);
        if (cellElem?.classList.contains('cell')) {
          const r = parseInt(cellElem.dataset.row);
          const c = parseInt(cellElem.dataset.col);
          createClump(r, c);
          renderGrid();
        }
      }, { passive: false });

      gridElem.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isInteracting) return;
        
        hasMoved = true;  // Set movement flag
        const touch = e.touches[0];
        if (lastTouch && 
            Math.abs(touch.clientX - lastTouch.clientX) < 2 && 
            Math.abs(touch.clientY - lastTouch.clientY) < 2) {
          return;
        }
        
        lastTouch = touch;
        const cellElem = document.elementFromPoint(touch.clientX, touch.clientY);
        if (cellElem?.classList.contains('cell')) {
          const r = parseInt(cellElem.dataset.row);
          const c = parseInt(cellElem.dataset.col);
          const cellKey = `${r},${c}`;
          if (lastCell !== cellKey) {
            lastCell = cellKey;
            createClump(r, c);
            renderGrid();
          }
        }
      }, { passive: false });

      gridElem.addEventListener('touchend', (e) => {
        if (isInteracting && !hasMoved) {
          // If it was just a tap (no movement), create another clump
          const touch = e.changedTouches[0];
          const cellElem = document.elementFromPoint(touch.clientX, touch.clientY);
          if (cellElem?.classList.contains('cell')) {
            const r = parseInt(cellElem.dataset.row);
            const c = parseInt(cellElem.dataset.col);
            createClump(r, c);
            renderGrid();
          }
        }
        isInteracting = false;
        lastCell = null;
        lastTouch = null;
      });

      gridElem.addEventListener('touchcancel', () => {
        isInteracting = false;
        lastCell = null;
        lastTouch = null;
      });
    }

    // Separate mouse handler setup
    function setupMouseHandlers(gridElem) {
      let isInteracting = false;
      let lastCell = null;
      let hasMoved = false;  // Add this to track if mouse has moved

      gridElem.addEventListener('mousedown', (e) => {
        isInteracting = true;
        hasMoved = false;  // Reset movement flag
        const cellDiv = e.target;
        if (cellDiv.classList.contains('cell')) {
          const r = parseInt(cellDiv.dataset.row);
          const c = parseInt(cellDiv.dataset.col);
          createClump(r, c);
          renderGrid();
        }
      });

      gridElem.addEventListener('mousemove', (e) => {
        if (isInteracting) {
          hasMoved = true;  // Set movement flag
          const cellDiv = e.target;
          if (cellDiv.classList.contains('cell')) {
            const r = parseInt(cellDiv.dataset.row);
            const c = parseInt(cellDiv.dataset.col);
            if (lastCell !== `${r},${c}`) {
              lastCell = `${r},${c}`;
              createClump(r, c);
              renderGrid();
            }
          }
        }
      });

      gridElem.addEventListener('mouseup', (e) => {
        if (isInteracting && !hasMoved) {
          // If it was just a click (no movement), create another clump
          const cellDiv = e.target;
          if (cellDiv.classList.contains('cell')) {
            const r = parseInt(cellDiv.dataset.row);
            const c = parseInt(cellDiv.dataset.col);
            createClump(r, c);
            renderGrid();
          }
        }
        isInteracting = false;
        lastCell = null;
      });

      gridElem.addEventListener('mouseleave', () => {
        isInteracting = false;
        lastCell = null;
      });
    }

    // Create a random clump of live cells around the clicked point
    function createClump(centerR, centerC) {
      const radius = 2;
      for (let dr = -radius; dr <= radius; dr++) {
        for (let dc = -radius; dc <= radius; dc++) {
          const r = centerR + dr;
          const c = centerC + dc;
          if (r >= 0 && r < rows && c >= 0 && c < cols) {
            // Random chance of cell being alive, higher chance closer to center
            const distance = Math.sqrt(dr * dr + dc * dc);
            const probability = 0.8 - (distance / radius) * 0.5;
            grid[r][c] = Math.random() < probability ? 1 : 0;
          }
        }
      }
    }

    // -----------------------------------------------------
    // Rendering
    // -----------------------------------------------------
    function renderGrid() {
      const allCells = document.querySelectorAll("#grid .cell");
      allCells.forEach((cellDiv) => {
        const r = parseInt(cellDiv.dataset.row);
        const c = parseInt(cellDiv.dataset.col);
        cellDiv.classList.toggle("alive", grid[r][c] === 1);
      });
    }

    // -----------------------------------------------------
    // Game Logic
    // -----------------------------------------------------
    function computeNextGeneration(currentGrid) {
      const newGrid = createEmptyGrid(rows, cols);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const neighbors = countNeighbors(currentGrid, r, c);
          const cellState = currentGrid[r][c];
          if (cellState === 1) {
            newGrid[r][c] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
          } else {
            newGrid[r][c] = (neighbors === 3) ? 1 : 0;
          }
        }
      }
      return newGrid;
    }

    function countNeighbors(g, row, col) {
      let count = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = row + dr;
          const nc = col + dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            count += g[nr][nc];
          }
        }
      }
      return count;
    }

    function allCellsDead(g) {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] === 1) return false;
        }
      }
      return true;
    }

    // -----------------------------------------------------
    // Pattern Loading
    // -----------------------------------------------------
    function loadPattern(patternName) {
      try {
        if (!patterns[patternName]) return;
        stopGame();
        
        // Clear grid first
        grid = createEmptyGrid(rows, cols);

        // Calculate bounding box of pattern
        const pattern = patterns[patternName];
        let minRow = Infinity, maxRow = -Infinity;
        let minCol = Infinity, maxCol = -Infinity;
        pattern.forEach(([r, c]) => {
          if (r < minRow) minRow = r;
          if (r > maxRow) maxRow = r;
          if (c < minCol) minCol = c;
          if (c > maxCol) maxCol = c;
        });

        const patternHeight = maxRow - minRow + 1;
        const patternWidth = maxCol - minCol + 1;
        const rowOffset = Math.floor(rows / 2 - patternHeight / 2) - minRow;
        const colOffset = Math.floor(cols / 2 - patternWidth / 2) - minCol;

        // Populate the grid
        pattern.forEach(([r, c]) => {
          const newR = r + rowOffset;
          const newC = c + colOffset;
          if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
            grid[newR][newC] = 1;
          }
        });

        // Force a full redraw
        renderGrid();

        // Start playing automatically
        startGame();
        document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';
      } catch (error) {
        console.error('Error loading pattern:', error);
        clearGrid();
      }
    }

    // -----------------------------------------------------
    // Controls
    // -----------------------------------------------------
    function startGame() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      
      if (allCellsDead(grid)) {
        randomizeGrid();
      }
      
      playing = true;
      // Disable zoom control while playing
      document.getElementById("zoomSelect").disabled = true;
      
      timer = setInterval(() => {
        grid = computeNextGeneration(grid);
        renderGrid();
      }, calculateInterval());
    }

    function stopGame() {
      playing = false;
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>';

      // Re-enable zoom control when stopped
      document.getElementById("zoomSelect").disabled = false;
    }

    function toggleGame() {
      if (playing) {
        stopGame();
      } else {
        startGame();
        document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';
      }
    }

    function stepGeneration() {
      stopGame();
      grid = computeNextGeneration(grid);
      renderGrid();
    }

    function randomizeGrid() {
      stopGame();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          grid[r][c] = Math.random() > 0.8 ? 1 : 0;
        }
      }
      renderGrid();
    }

    function clearGrid() {
      stopGame();
      grid = createEmptyGrid(rows, cols);
      renderGrid();
    }

    function calculateInterval() {
      // 1.0 speed = 200 ms
      return baseInterval / currentSpeedMultiplier;
    }
  </script>

  <!-- cite original Tokyo Night reference in markdown, as requested -->
  <p style="display:none;">
    Referenced from [Tokyo Night VSCode Theme](https://github.com/tokyo-night/tokyo-night-vscode-theme)
  </p>

  <!-- Instructions Modal -->
  <div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-game">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="instructionsModalLabel">How it works</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>
            <strong>Select</strong> any area to create clusters of cells, or <strong>select and drag</strong> 
            to draw living paths. Press <strong>Play</strong> to watch your creation evolve, or use <strong>Step Forward</strong> 
            to advance one generation at a time. Use <strong>Randomize</strong> for chaos, 
            or <strong>Clear</strong> to start fresh.
          </p>
          
          <h6>The Rules</h6>
          <p>
            Each cell follows four simple rules in every generation:
            <ul>
              <li><strong>Underpopulation:</strong> A living cell with fewer than 2 neighbors dies</li>
              <li><strong>Survival:</strong> A living cell with 2 or 3 neighbors survives</li>
              <li><strong>Overpopulation:</strong> A living cell with more than 3 neighbors dies</li>
              <li><strong>Reproduction:</strong> A dead cell with exactly 3 neighbors becomes alive</li>
            </ul>
          </p>
          
          <h6>Controls</h6>
          <p>
            <ul>
              <li><strong>Play/Pause:</strong> Start or stop the simulation</li>
              <li><strong>Step Forward:</strong> Advance one generation at a time</li>
              <li><strong>Speed:</strong> Adjust how quickly generations pass</li>
              <li><strong>Zoom:</strong> Change the grid size (only while paused)</li>
            </ul>
          </p>
          
          <h6>Pattern Examples</h6>
          <p class="mb-0">
            Try the preset patterns to see different behaviors:
            <ul class="mb-0">
              <li><strong>Glider:</strong> A pattern that moves diagonally across the grid</li>
              <li><strong>Pulsar:</strong> A large pattern that oscillates with a period of 3 generations</li>
              <li><strong>Small Exploder:</strong> A pattern that expands outward chaotically</li>
            </ul>
          </p>
        </div>
      </div>
    </div>
</div>
</body>
</html>