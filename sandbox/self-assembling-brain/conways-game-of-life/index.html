<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4JE9G63Y9Z"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4JE9G63Y9Z');
  </script>
  <meta charset="UTF-8" />
  <title>Conway's Game of Life - Blake Crosley Sandbox</title>
  <!-- Viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Twitter Card data -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@BlakeC">
  <meta name="twitter:creator" content="@BlakeC">
  <meta name="twitter:title" content="Conway's Game of Life - Interactive Simulation">
  <meta name="twitter:description" content="Watch simple rules create complex life. Draw patterns and witness digital organisms evolve in this mesmerizing cellular automaton.">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/blakecrosley/supahost/main/sandbox/self-assembling-brain/conways-game-of-life/preview.png">
  <meta name="twitter:image:alt" content="Conway's Game of Life simulation showing evolving patterns">
  <meta name="twitter:domain" content="github.blakecrosley.com">
  <meta name="twitter:url" content="https://github.blakecrosley.com/sandbox/self-assembling-brain/conways-game-of-life/">
  
  <!-- Open Graph data (also used by other platforms) -->
  <meta property="og:title" content="Conway's Game of Life - Interactive Simulation">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://github.blakecrosley.com/sandbox/self-assembling-brain/conways-game-of-life/">
  <meta property="og:image" content="https://raw.githubusercontent.com/blakecrosley/supahost/main/sandbox/self-assembling-brain/conways-game-of-life/preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:description" content="Explore emergence and complexity with this interactive Game of Life simulation. Draw patterns, watch them evolve, and discover how simple rules create fascinating behaviors.">
  <meta property="og:site_name" content="Blake Crosley's Sandbox">

  <!-- Apple Messages Preview -->
  <meta name="apple-mobile-web-app-title" content="Conway's Game of Life">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="https://github.blakecrosley.com/sandbox/self-assembling-brain/conways-game-of-life/preview-icon.png">
  <!-- Apple Messages Link Preview -->
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Apple Messages Fallback -->
  <link rel="mask-icon" href="https://github.blakecrosley.com/sandbox/self-assembling-brain/conways-game-of-life/preview-icon.png" color="#24283b">

  <!-- Bootstrap 5.3.3 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" 
    rel="stylesheet"
  />

  <!-- Add this after Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <style>
    /* Tokyo Night colors from https://github.com/tokyo-night/tokyo-night-vscode-theme */
    :root {
      --tn-bg: #1a1b26;         /* Primary background */
      --tn-panel: #24283b;      /* Panel/secondary backgrounds */
      --tn-foreground: #c0caf5; /* Main text color */
      --tn-btn-bg: #414868;     /* Button background */
      --tn-btn-bg-hover: #565f89;
      --tn-btn-text: #c0caf5;
      --tn-border: #565f89;
    }

    /* Overall page styling */
    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--tn-bg) !important;
      color: var(--tn-foreground) !important;
      font-size: 20px;
      line-height: 1.4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding-top: 120px;
      padding-bottom: 0px;
    }

    /* Navbar inherits panel color */
    .navbar {
      background-color: rgba(36, 40, 59, 0.8) !important;
      border-bottom: 1px solid var(--tn-border);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Buttons */
    .btn-secondary {
      background-color: var(--tn-btn-bg) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      border-color: var(--tn-border) !important;
    }

    .btn-outline-secondary {
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-outline-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }

    /* Form Controls (like .form-select) */
    .form-select {
      background-color: var(--tn-panel) !important;
      color: var(--tn-foreground) !important;
      border-color: var(--tn-border) !important;
    }
    .form-select:focus {
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(108,117,125,.5); /* or customize further */
    }

    /* Grid container */
    #grid-container {
      margin: 0 auto;
      border: 1px solid var(--tn-border);
      border-radius: .5rem;
      background: var(--tn-panel);
      box-sizing: border-box;
      width: 100%;
      position: relative;
      padding-bottom: 60%;
      overflow: hidden;
      cursor: crosshair;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #zoomControls {
      margin: 16px 0;
    }

    /* Control buttons row spacing */
    #gameControls {
      margin-bottom: 16px;
    }

    /* The container that we transform for zooming */
    #gridWrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #grid {
      display: grid;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      gap: 0;
      background: var(--tn-border);
      cursor: crosshair;
    }

    .cell {
      width: 100%;
      height: 100%;
      background-color: #24283b; /* match main background or #24283b if preferred */
      box-sizing: border-box;
      cursor: crosshair;
    }
    .alive {
      background-color: #88f9d7; /* Vibrant green from Tokyo Night theme */
    }

    #exampleControls .btn-check:checked + .btn {
      background-color: #88f9d7 !important; /* Vibrant green for active state */
      color: #1a1b26 !important;           /* Dark text for contrast */
      border-color: #88f9d7 !important;
    }

    /* Increase margin top/bottom to 2em for headings and paragraphs */
    h1, h2, h3, h4, h5, h6  {
      margin-top: 0em;
      margin-bottom: .5em;
      color: rgb(245, 133, 237);
      font-weight: bold;
    }

    /* Link styling using the heading color */
    a.instructions-link {
      color: rgb(245, 133, 237);
      text-decoration: underline;
      transition: all 0.2s ease;
    }
    
    a.instructions-link:hover {
      color: rgb(250, 164, 244);
      text-decoration: underline;
      text-underline-offset: 4px;
    }
    
    a.instructions-link:active {
      color: rgb(219, 119, 212);
    }

    p {
      margin-bottom: 1em;
    }
    p.mb-large {
      margin-bottom: 3em;
    }
    #exampleControls {
      margin-bottom: 2em;
    }

    /* Ensure all control buttons have consistent padding */
    .btn-group .btn {
      padding: 0.5rem 1rem;
    }

    .footer {
      background-color: var(--tn-panel);
      border-top: 1px solid var(--tn-border);
      position: relative;
      bottom: 0;
      width: 100%;
      padding: 1rem 0;
    }
    
    .text-muted {
      color: var(--tn-foreground) !important;
      opacity: 0.7;
    }

    .footer-links a {
      color: var(--tn-foreground);
      opacity: 0.7;
      text-decoration: none;
      margin: 0.5rem;
      transition: opacity 0.2s ease;
    }

    .footer-links a:hover {
      opacity: 1;
    }
    .mw-100 {
      max-width: 100%;
    }

    /* Modal styling */
    .modal-content {
      background: var(--tn-panel);
      border: 1px solid var(--tn-border);
    }
    
    .modal-header {
      border-bottom-color: var(--tn-border);
    }
    
    .modal-dialog-game {
      max-width: 66.666667%;
    }

    .cell:active,
    .cell.dragging {
      cursor: cell;
    }

    @media (hover: none) and (pointer: coarse) {
      #grid-container {
        -webkit-overflow-scrolling: touch;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      #gridWrapper {
        transform-origin: center center;
        -webkit-transform-origin: center center;
        will-change: transform;
      }

      #grid {
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }

      .cell {
        /* Remove min-width/height constraints - let the grid system handle it */
        min-width: initial;
        min-height: initial;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        touch-action: none;
      }
    }

    /* Specific iOS fixes */
    @supports (-webkit-touch-callout: none) {
      #grid-container {
        position: relative;
        z-index: 1;
      }
      
      #gridWrapper {
        position: absolute;
        width: 100%;
        height: 100%;
        transform-style: flat;
        -webkit-transform-style: flat;
      }
    }

    .form-select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #loadingState {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--tn-panel);
      border-radius: .5rem;
      z-index: 10;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 1rem;
    }

    .spinner {
      width: 3rem;
      height: 3rem;
      border: 0.25rem solid var(--tn-border);
      border-top-color: var(--tn-foreground);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #grid-container {
      position: relative; /* Ensure this is set */
    }

    /* Fade transition classes */
    .fade-out {
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .fade-in {
      opacity: 1;
      transition: opacity 0.2s ease-in;
    }

    /* Add to your existing styles */
    .navbar-toggler {
      border-color: var(--tn-border);
      padding: 0.25rem 0.5rem;
    }

    .navbar-toggler:focus {
      box-shadow: none;
      border-color: var(--tn-foreground);
    }

    .navbar-toggler .bi-list {
      font-size: 1.5rem;
    }

    /* Mobile-specific navbar styles */
    @media (max-width: 991.98px) {
      .navbar .navbar-collapse {
        padding: 1rem 0;
      }
      
      .navbar .navbar-nav {
        gap: 0.5rem;
      }
      
      .navbar .btn {
        width: 100%;
        margin: 0 !important;
      }
    }

    /* Mobile footer styles */
    @media (max-width: 768px) {
      .footer {
        margin: 0;
        padding: 1rem 0;
      }

      .footer .container {
        padding: 0;
        margin: 0;
        max-width: 100%;
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }

      .footer-links {
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }
      
      .footer-social {
        justify-content: center;
        margin: 0.5rem 0;
      }
      
      .footer-links a {
        margin: 0.5rem;
      }
    }

    .footer-container {
      padding: 0;
      margin: 0;
    }

    /* Footer base styles */
    .footer-links {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .footer-social {
      display: flex;
      gap: 1.5rem;
    }

    /* Mobile footer styles */
    @media (max-width: 768px) {
      .footer {
        margin: 0;
        padding: 1rem 0;
      }

      .footer .container {
        padding: 0;
        margin: 0;
        max-width: 100%;
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .footer-links {
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }
      
      .footer-social {
        justify-content: center;
        margin: 0.5rem 0;
      }
    }

    /* Add these new styles */
    .cell.hover-highlight {
        background-color: #2a2e43; /* Slightly lighter than the default #24283b */
        transition: background-color 0.1s ease;
    }

    .alive.hover-highlight {
        background-color: #9ffae2; /* Slightly lighter than the alive color #88f9d7 */
    }
  </style>

  <link rel="icon" type="image/png" href="../../../favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="../../../favicon/favicon.svg" />
  <link rel="shortcut icon" href="../../../favicon/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png" />
  <link rel="manifest" href="../../../favicon/site.webmanifest" />

</head>

<body>
  <!-- Bootstrap 5 Navbar -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a href="https://x.com/BlakeC" class="navbar-brand text-decoration-none" target="_blank">
        <img src="../../../assets/profile.jpg" 
             alt="@blakec" 
             class="rounded-circle me-2" 
             style="width: 32px; height: 32px;">
        @blakec
      </a>
      
      <!-- Hamburger button for mobile -->
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" 
              data-bs-target="#navbarContent" aria-controls="navbarContent" 
              aria-expanded="false" aria-label="Toggle navigation">
        <i class="bi bi-list text-light"></i>
      </button>
      
      <!-- Collapsible content -->
      <div class="collapse navbar-collapse" id="navbarContent">
        <div class="navbar-nav ms-auto">
          <a href="https://blakecrosley.com" class="btn btn-outline-secondary me-2" target="_blank">
            blakecrosley.com
          </a>
          <a href="https://941apps.com" class="btn btn-outline-secondary" target="_blank">
            941apps.com
          </a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Main container: Use a Bootstrap container and row -->
  <div class="container-fluid">
    <div class="row">
      <!-- 8 columns wide on large screens, 12 on smaller, with offset for center -->
      <div class="col-12 col-lg-8 offset-lg-2">
        
        <!-- BEGIN game functionality section -->
        <!-- Control buttons row -->
        <div class="row" id="gameControls">
          <div class="col-12 d-flex flex-wrap align-items-center justify-content-between">
            <h1>Conway's Game of Life</h1>

            <!-- Editorial description -->
            <div id="description">
              <p>
                Conway's Game of Life is a classic example of how complexity can blossom from just a few 
                straightforward rules. Picture an infinite grid of cells—each one can be "on" (alive) or 
                "off" (dead). Each turn (or "generation"), every cell checks how many neighbors are alive. 
                If it's overcrowded, it dies. If it's too lonely, it also dies. But with exactly three 
                neighbors, a dead cell will spark into life.
              </p>
              <p>
                This simple set of rules leads to endlessly fascinating behavior—from stable formations 
                and repeating oscillators, to self-propagating "spaceships" that traverse the grid. 
                It's a perfect demonstration of how complexity can arise from simplicity, and it's even 
                Turing complete, meaning it can, in theory, simulate any computation.
              </p>
              <p class="mb-large">
                <a href="#" class="instructions-link" data-bs-toggle="modal" data-bs-target="#instructionsModal">
                  How it works
                </a>
              </p>
  </div>

            <!-- Button group -->
            <div class="btn-group btn-group-lg" role="group" aria-label="Game controls">
              <button id="toggleBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>
              </button>
              <button id="stepBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-skip-end"></i> <span class="d-none d-sm-inline">Step Forward</span>
              </button>
              <button id="randomBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-dice-6"></i> <span class="d-none d-sm-inline">Randomize</span>
              </button>
              <button id="clearBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-x-circle"></i> <span class="d-none d-sm-inline">Clear</span>
              </button>
            </div>
            <!-- Speed select -->
            <div class="ms-3 d-inline-flex align-items-center">
              <label for="speedSelect" class="form-label me-2 mb-0">Speed</label>
              <select id="speedSelect" class="form-select form-select-lg" style="width:auto;" aria-label="Speed">
        <option value="0.5">0.5×</option>
        <option value="1.0" selected>1.0×</option>
        <option value="1.5">1.5×</option>
        <option value="2.0">2.0×</option>
      </select>
    </div>
    </div>    
    </div>

    <!-- Transform #grid into a <canvas> for rendering -->
    <div id="grid-container">
      <div id="loadingState">
        <div class="spinner"></div>
        <div>Loading game board...</div>
      </div>
      <div id="gridWrapper">
        <!-- Replace the old <div id="grid"></div> with a canvas -->
        <canvas id="grid"></canvas>
      </div>
    </div>

    <!-- Zoom controls -->
    <div class="d-flex justify-content-end align-items-center" id="zoomControls">
      <label for="zoomSelect" class="form-label me-2 mb-0">Zoom</label>
      <select id="zoomSelect" class="form-select form-select-lg d-inline-block" style="width:auto;">
        <option value="1" selected>1×</option>
        <option value="2">2×</option>
        <option value="3">3×</option>
      </select>
    </div>

    <!-- Pattern section -->
    <h3>Pattern Examples</h3>
    <div id="instructions">
      <p>
        These classic patterns showcase the Game's emergent behavior. The "Glider" demonstrates movement 
        across the grid, the "Pulsar" creates a mesmerizing oscillation, and the "Small Exploder" shows 
        how simple shapes can evolve into complex forms.
      </p>
    </div>
    <div id="exampleControls" class="d-flex gap-2 flex-wrap mb-large">
      <!-- Example pattern checkboxes (to be toggled in script) -->
      <div class="btn-group" role="group">
        <input type="checkbox" class="btn-check" id="gliderBtn" autocomplete="off" value="glider">
        <label class="btn btn-outline-secondary" for="gliderBtn">Glider</label>
      </div>
      <div class="btn-group" role="group">
        <input type="checkbox" class="btn-check" id="pulsarBtn" autocomplete="off" value="pulsar">
        <label class="btn btn-outline-secondary" for="pulsarBtn">Pulsar</label>
      </div>
      <div class="btn-group" role="group">
        <input type="checkbox" class="btn-check" id="smallExploderBtn" autocomplete="off" value="smallExploder">
        <label class="btn btn-outline-secondary" for="smallExploderBtn">Small Exploder</label>
      </div>
    </div>

    <!-- Code Showcase -->
    <h3>The Algorithm</h3>
    <p>At its heart, the Game of Life runs on just a few elegant functions that determine life and death in our cellular universe:</p>
    
    <div class="code-showcase" style="background: #1a1b26; border-radius: .5rem; margin: 1rem 0 3rem 0;">
      <!-- Core Algorithm -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; overflow-x: auto; margin: 0; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// The core algorithm that determines life and death</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">computeNextGeneration</span>(<span style="color: #e0af68;">currentGrid</span>) {
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">newGrid</span> = <span style="color: #7aa2f7;">createEmptyGrid</span>(<span style="color: #7dcfff;">rows</span>, <span style="color: #7dcfff;">cols</span>);
  
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> r = <span style="color: #ff9e64;">0</span>; r < <span style="color: #7dcfff;">rows</span>; r++) {
    <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> c = <span style="color: #ff9e64;">0</span>; c < <span style="color: #7dcfff;">cols</span>; c++) {
      <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">neighbors</span> = <span style="color: #7aa2f7;">countNeighbors</span>(<span style="color: #e0af68;">currentGrid</span>, r, c);
      <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">cellState</span> = <span style="color: #e0af68;">currentGrid</span>[r][c];

      <span style="color: #565f89;">// Apply Conway's rules of life</span>
      <span style="color: #bb9af7;">if</span> (<span style="color: #7dcfff;">cellState</span> === <span style="color: #ff9e64;">1</span>) {
        <span style="color: #565f89;">// Live cell survives if it has 2 or 3 neighbors</span>
        <span style="color: #7dcfff;">newGrid</span>[r][c] = (<span style="color: #7dcfff;">neighbors</span> === <span style="color: #ff9e64;">2</span> || <span style="color: #7dcfff;">neighbors</span> === <span style="color: #ff9e64;">3</span>) ? <span style="color: #ff9e64;">1</span> : <span style="color: #ff9e64;">0</span>;
      } <span style="color: #bb9af7;">else</span> {
        <span style="color: #565f89;">// Dead cell springs to life if it has exactly 3 neighbors</span>
        <span style="color: #7dcfff;">newGrid</span>[r][c] = (<span style="color: #7dcfff;">neighbors</span> === <span style="color: #ff9e64;">3</span>) ? <span style="color: #ff9e64;">1</span> : <span style="color: #ff9e64;">0</span>;
      }
    }
  }
  <span style="color: #bb9af7;">return</span> <span style="color: #7dcfff;">newGrid</span>;
}</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        The core algorithm applies Conway's rules to each cell in the grid. For each generation, it checks every cell's 
        state and its neighbor count to determine if it lives, dies, or springs to life. This creates the mesmerizing 
        patterns we see evolving on the board.
      </p>

      <!-- Neighbor Counting -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; margin-bottom: 0; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Count live neighbors for each cell</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">countNeighbors</span>(<span style="color: #e0af68;">g</span>, <span style="color: #e0af68;">row</span>, <span style="color: #e0af68;">col</span>) {
  <span style="color: #bb9af7;">let</span> <span style="color: #7dcfff;">count</span> = <span style="color: #ff9e64;">0</span>;
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> i = <span style="color: #ff9e64;">0</span>; i < <span style="color: #ff9e64;">8</span>; i++) {
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">nr</span> = <span style="color: #e0af68;">row</span> + <span style="color: #7aa2f7;">NEIGHBOR_OFFSETS</span>[i * <span style="color: #ff9e64;">2</span>];
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">nc</span> = <span style="color: #e0af68;">col</span> + <span style="color: #7aa2f7;">NEIGHBOR_OFFSETS</span>[i * <span style="color: #ff9e64;">2</span> + <span style="color: #ff9e64;">1</span>];
    <span style="color: #bb9af7;">if</span> (<span style="color: #7dcfff;">nr</span> >= <span style="color: #ff9e64;">0</span> && <span style="color: #7dcfff;">nr</span> < <span style="color: #7dcfff;">rows</span> && <span style="color: #7dcfff;">nc</span> >= <span style="color: #ff9e64;">0</span> && <span style="color: #7dcfff;">nc</span> < <span style="color: #7dcfff;">cols</span>) {
      <span style="color: #7dcfff;">count</span> += <span style="color: #e0af68;">g</span>[<span style="color: #7dcfff;">nr</span>][<span style="color: #7dcfff;">nc</span>];
    }
  }
  <span style="color: #bb9af7;">return</span> <span style="color: #7dcfff;">count</span>;
}</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        The neighbor counting function scans the eight cells surrounding each position. It carefully handles edge cases 
        and provides the vital information needed to apply Conway's rules. This efficient implementation uses simple 
        addition since living cells are represented as 1's and dead cells as 0's.
      </p>

      <!-- Pattern Loading -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Load and center a predefined pattern on the grid</span>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">loadPattern</span>(<span style="color: #e0af68;">patternName</span>) {
  <span style="color: #bb9af7;">if</span> (!<span style="color: #7aa2f7;">patterns</span>[<span style="color: #e0af68;">patternName</span>]) <span style="color: #bb9af7;">return</span>;
  
  <span style="color: #565f89;">// Calculate pattern dimensions</span>
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">pattern</span> = <span style="color: #7aa2f7;">patterns</span>[<span style="color: #e0af68;">patternName</span>];
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">bounds</span> = calculatePatternBounds(pattern);
  
  <span style="color: #565f89;">// Center the pattern</span>
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">rowOffset</span> = <span style="color: #7aa2f7;">Math</span>.floor(<span style="color: #7dcfff;">rows</span> / <span style="color: #ff9e64;">2</span> - <span style="color: #7dcfff;">bounds</span>.height / <span style="color: #ff9e64;">2</span>);
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">colOffset</span> = <span style="color: #7aa2f7;">Math</span>.floor(<span style="color: #7dcfff;">cols</span> / <span style="color: #ff9e64;">2</span> - <span style="color: #7dcfff;">bounds</span>.width / <span style="color: #ff9e64;">2</span>);
  
  <span style="color: #565f89;">// Place the pattern on the grid</span>
  <span style="color: #7dcfff;">pattern</span>.<span style="color: #7aa2f7;">forEach</span>(<span style="color: #bb9af7;">([</span><span style="color: #7dcfff;">r</span>, <span style="color: #7dcfff;">c</span><span style="color: #bb9af7;">])</span> => {
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">newR</span> = r + rowOffset;
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">newC</span> = c + colOffset;
    <span style="color: #bb9af7;">if</span> (<span style="color: #7aa2f7;">isValidCell</span>(<span style="color: #7dcfff;">newR</span>, <span style="color: #7dcfff;">newC</span>)) {
      <span style="color: #7dcfff;">grid</span>[<span style="color: #7dcfff;">newR</span>][<span style="color: #7dcfff;">newC</span>] = <span style="color: #ff9e64;">1</span>;
    }
  });
}</code></pre>

      <p style="color: #c0caf5; margin: 1em 0;">
        Pattern loading is what allows us to place predefined structures onto the grid. It automatically centers the pattern 
        and ensures it fits within the boundaries. This function transforms the simple coordinate lists below into living 
        cells on our grid.
      </p>

      <!-- Pattern Definitions -->
      <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Classic patterns that demonstrate emergent behavior</span>
<span style="color: #bb9af7;">const</span> <span style="color: #7aa2f7;">patterns</span> = {
  <span style="color: #565f89;">// Glider - Moves diagonally across the grid indefinitely</span>
  <span style="color: #7aa2f7;">glider</span>: [
    [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">1</span>],                     <span style="color: #565f89;">// Top</span>
    [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">2</span>],                     <span style="color: #565f89;">// Middle</span>
    [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">2</span>]      <span style="color: #565f89;">// Bottom</span>
  ],

  <span style="color: #565f89;">// Pulsar - Large symmetric oscillator with period 3</span>
  <span style="color: #7aa2f7;">pulsar</span>: [
    <span style="color: #565f89;">// Outer frame</span>
    [-<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">2</span>], [-<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">1</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">0</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">1</span>], [-<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">2</span>],
    [<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">2</span>], [<span style="color: #ff9e64;">4</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">4</span>, <span style="color: #ff9e64;">2</span>],
    <span style="color: #565f89;">// Inner structure</span>
    [-<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">4</span>], [-<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">0</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">4</span>],
    [-<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">4</span>], [-<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">4</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">4</span>]
  ],

  <span style="color: #565f89;">// Small Exploder - Rapidly expands into chaotic patterns</span>
  <span style="color: #7aa2f7;">smallExploder</span>: [
    [<span style="color: #ff9e64;">0</span>, <span style="color: #ff9e64;">0</span>],                     <span style="color: #565f89;">// Core</span>
    [<span style="color: #ff9e64;">1</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">0</span>], [<span style="color: #ff9e64;">1</span>, <span style="color: #ff9e64;">1</span>],    <span style="color: #565f89;">// Center</span>
    [<span style="color: #ff9e64;">2</span>, -<span style="color: #ff9e64;">1</span>], [<span style="color: #ff9e64;">2</span>, <span style="color: #ff9e64;">1</span>],            <span style="color: #565f89;">// Sides</span>
    [<span style="color: #ff9e64;">3</span>, <span style="color: #ff9e64;">0</span>]                      <span style="color: #565f89;">// Tail</span>
  ]
};</code></pre>

      <p style="color: #c0caf5; margin: 1em 0 3em 0;">
        These pattern definitions encode classic Game of Life structures using coordinate pairs. Each pattern demonstrates 
        different emergent behaviors: the Glider moves endlessly across the grid, the Pulsar oscillates in place, and 
        the Small Exploder creates expanding chaos from a tiny seed.
      </p>

      <!-- Link to Rule 110 -->
      <div class="text-center mb-5">
        <a href="../rule-110/" class="btn btn-lg" style="
          background: transparent;
          border: 2px solid rgb(245, 133, 237);
          color: rgb(245, 133, 237);
          transition: all 0.2s ease;
          font-weight: 600;
          padding: 0.75rem 1.5rem;
          " onmouseover="this.style.background='rgba(245, 133, 237, 0.1)';this.style.borderColor='rgb(250, 164, 244)';this.style.color='rgb(250, 164, 244)'" 
          onmouseout="this.style.background='transparent';this.style.borderColor='rgb(245, 133, 237)';this.style.color='rgb(245, 133, 237)'"
          onmousedown="this.style.background='rgba(245, 133, 237, 0.2)';this.style.borderColor='rgb(219, 119, 212)';this.style.color='rgb(219, 119, 212)'"
          onmouseup="this.style.background='rgba(245, 133, 237, 0.1)';this.style.borderColor='rgb(250, 164, 244)';this.style.color='rgb(250, 164, 244)'"
        >
          View Wolfram's Rule 110 →
        </a>
      </div>

    </div>

    <!-- END game functionality section -->
  
  </div>
  </div>
  <!-- Footer -->
  <div class="container-fluid footer-container">
    <div class="row">
      <footer class="footer mt-auto">
        <div class="container d-flex justify-content-between align-items-center mw-100">
          <span class="text-muted">© 2025</span>
          <div class="footer-links">
            <div class="">
              <a href="https://x.com/BlakeC" target="_blank" title="X (Twitter)">
                <i class="bi bi-twitter-x"></i>
              </a>
              <a href="https://github.com/blakecrosley" target="_blank" title="GitHub">
                <i class="bi bi-github"></i>
              </a>
            </div>
            <a href="https://blakecrosley.com" target="_blank" title="Personal Website">
              blakecrosley.com
            </a>
            <a href="https://941apps.com" target="_blank" title="941 Apps">
              941apps.com
            </a>
          </div>
        </div>
      </footer>
    </div>
  </div>


  <!-- Bootstrap 5.3.3 JS (includes Popper) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous">
  </script>

  <!-- Conway's Game of Life Script (Vanilla JS) -->
  <script>
    // Add these constants at the top of your script
    const BASE_FPS = 5; // 5 frames per second at 1x speed
    const BASE_INTERVAL = 1000 / BASE_FPS; // 200ms between frames at 1x speed

    // Add this before the existing code
    class GameState {
      constructor(baseRows = 30, baseCols = 50) {
        // Core grid properties
        this.baseRows = baseRows;
        this.baseCols = baseCols;
        this.rows = baseRows;
        this.cols = baseCols;
        
        // Game state
        this.playing = false;
        this.timer = null;
        this.grid = this.createEmptyGrid(this.rows, this.cols);
        
        // Performance settings
        this.baseInterval = 200;
        this.currentSpeedMultiplier = 1.0;
        this.currentZoom = 1.0;
        
        // FPS tracking
        this.frames = [];
        this.lastFrameTimeStamp = performance.now();
        this.lastRenderTime = 0;
      }

      createEmptyGrid(rows, cols) {
        return Array(rows).fill(null)
          .map(() => Array(cols).fill(0));
      }

      calculateInterval() {
        return this.baseInterval / this.currentSpeedMultiplier;
      }

      setSpeed(multiplier) {
        this.currentSpeedMultiplier = multiplier;
        if (this.playing) {
          this.restartTimer();
        }
      }

      restartTimer() {
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
      }

      updateFPS() {
        const now = performance.now();
        const delta = now - this.lastFrameTimeStamp;
        this.lastFrameTimeStamp = now;
        
        const fps = 1000 / delta;
        this.frames.push(fps);
        if (this.frames.length > 30) {
          this.frames.shift();
        }
      }

      getAverageFPS() {
        if (!this.frames.length) return 0;
        return this.frames.reduce((a, b) => a + b, 0) / this.frames.length;
      }
    }

    // Initialize state
    const gameState = new GameState();

    // -----------------------------------------------------
    // Configuration: Patterns, Gameplay
    // -----------------------------------------------------
    const patterns = {
      glider: [
        [0, 1],
        [1, 2],
        [2, 0],
        [2, 1],
        [2, 2],
      ],
      pulsar: [
        [-4, -2], [-4, -1], [-4, 0], [-4, 1], [-4, 2],
        [4, -2], [4, -1], [4, 0], [4, 1], [4, 2],
        [-2, -4], [-1, -4], [0, -4], [1, -4], [2, -4],
        [-2, 4], [-1, 4], [0, 4], [1, 4], [2, 4],
        [-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2],
        [-2, 2], [-1, 2], [0, 2], [1, 2], [2, 2],
        [-2, -1], [-2, 0], [-2, 1],
        [2, -1], [2, 0], [2, 1]
      ],
      smallExploder: [
        [0, 0], [1, -1], [1, 0], [1, 1],
        [2, -1], [2, 1], [3, 0]
      ]
    };

    let baseRows = 30;
    let baseCols = 50;
    let rows = baseRows;
    let cols = baseCols;
    let grid = createEmptyGrid(rows, cols);
    let playing = false;
    let timer = null;
    let baseInterval = 200; // ms
    let currentSpeedMultiplier = 1.0;
    let currentZoom = 1.0;

    // Add at the top of the script
    const DOM = {
      grid: document.getElementById('grid'),
      toggleBtn: document.getElementById('toggleBtn'),
      speedSelect: document.getElementById('speedSelect'),
      zoomSelect: document.getElementById('zoomSelect')
    };

    // On load, run initialization
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize our state management system
      const gameState = new GameState();
      const gameController = new GameController(gameState);
      const uiController = new GameUIController(gameController);
      
      // Initialize the grid size
      calculateGridDimensions();
      // Create the grid
      gameState.grid = gameState.createEmptyGrid(gameState.rows, gameState.cols);
      buildGridUI();

      // Attach event handlers
      document.getElementById("toggleBtn").addEventListener("click", toggleGame);
      document.getElementById("stepBtn").addEventListener("click", stepGeneration);
      document.getElementById("randomBtn").addEventListener("click", randomizeGrid);
      document.getElementById("clearBtn").addEventListener("click", clearGrid);

      document.getElementById("speedSelect").addEventListener("change", (e) => {
        currentSpeedMultiplier = parseFloat(e.target.value);
        if (playing) {
          // Restart the game with new speed
          clearInterval(timer);
          timer = setInterval(() => {
            grid = computeNextGeneration(grid);
            renderGrid();
            FPS.update();
          }, BASE_INTERVAL / currentSpeedMultiplier);
        }
      });

      // Pattern checkboxes
      ["gliderBtn", "pulsarBtn", "smallExploderBtn"].forEach((btnId) => {
        const btnElem = document.getElementById(btnId);
        btnElem?.addEventListener("change", (e) => {
          const isChecked = e.target.checked;
          if (isChecked) {
            // Uncheck other patterns
            ["gliderBtn", "pulsarBtn", "smallExploderBtn"]
              .filter((otherId) => otherId !== btnId)
              .forEach((otherId) => {
                document.getElementById(otherId).checked = false;
              });

            // Load and auto-play the selected pattern
            loadPattern(e.target.value);
          } else {
            // Stop game if user unchecks current pattern
            stopGame();
            document.getElementById("toggleBtn").textContent = "Play";
          }
        });
      });

      // Handle window resize with debounce
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          const dims = calculateGridDimensions();
          if (dims.rows !== rows || dims.cols !== cols) {
            rows = dims.rows;
            cols = dims.cols;
            grid = createEmptyGrid(rows, cols);
            buildGridUI();
          }
        }, 250);
      });

      // Listen for zoom changes
      const zoomSelect = document.getElementById("zoomSelect");
      zoomSelect.addEventListener("change", (e) => {
        if (!playing) {
          setZoom(parseFloat(e.target.value));
        }
      });
    });

    // -----------------------------------------------------
    // Grid Setup
    // -----------------------------------------------------
    function calculateGridDimensions() {
      const containerElem = document.getElementById("grid-container");
      // We won't change rows & cols dynamically for this example,
      // but if we did, we could measure containerElem.clientWidth & .clientHeight
      rows = 30;
      cols = 50;
      return { rows, cols };
    }

    // Revert the grid data structure to the original array-based implementation
    function createEmptyGrid(r, c) {
      const arr = [];
      for (let i = 0; i < r; i++) {
        arr[i] = [];
        for (let j = 0; j < c; j++) {
          arr[i][j] = 0;
        }
      }
      return arr;
    }

    // Keep the optimized neighbor offsets
    const NEIGHBOR_OFFSETS = new Int8Array([-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1]);
    const NEIGHBOR_COUNT = 8;

    function showLoading() {
      const loadingState = document.getElementById('loadingState');
      const gridWrapper = document.getElementById('gridWrapper');
      
      // Fade out grid
      gridWrapper.classList.add('fade-out');
      
      // Show loading state with fade in
      loadingState.style.display = 'flex';
      // Force reflow
      void loadingState.offsetWidth;
      loadingState.classList.add('fade-in');
    }

    function hideLoading() {
      const loadingState = document.getElementById('loadingState');
      const gridWrapper = document.getElementById('gridWrapper');
      
      // Fade in grid
      gridWrapper.classList.remove('fade-out');
      
      // Hide loading state
      loadingState.classList.remove('fade-in');
      setTimeout(() => {
        loadingState.style.display = 'none';
      }, 200); // Match transition duration
    }

    async function setZoom(zoomValue) {
      if (playing) return;

      showLoading();

      try {
        // Store old grid state
        const oldGrid = grid;
        const oldRows = rows;
        const oldCols = cols;

        // Update dimensions
        rows = Math.floor(baseRows * zoomValue);
        cols = Math.floor(baseCols * zoomValue);

        const newGrid = createEmptyGrid(rows, cols);
        const rowOffset = Math.floor((rows - oldRows) / 2);
        const colOffset = Math.floor((cols - oldCols) / 2);

        // Copy existing pattern
        for (let r = 0; r < oldRows; r++) {
          for (let c = 0; c < oldCols; c++) {
            const newR = r + rowOffset;
            const newC = c + colOffset;
            if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
              newGrid[newR][newC] = oldGrid[r][c];
            }
          }
        }

        grid = newGrid;

        // Remove transform-based zoom
        const gridWrapper = document.getElementById('gridWrapper');
        gridWrapper.style.transform = '';
        
        // Build the grid UI
        await buildGridUI();

        // Hide loading after everything is done
        hideLoading();
      } catch (error) {
        console.error('Error during zoom:', error);
        hideLoading();
      }
    }

    // 1. Modified "buildGridUI" to create/size the canvas instead of DOM cells
    function buildGridUI() {
      return new Promise(resolve => {
        const containerElem = document.getElementById("grid-container");
        const gridElem = document.getElementById("grid"); // now a <canvas>

      gridElem.innerHTML = "";
        console.log("[Canvas Rendering] Initializing canvas UI...");

        // Intentionally match canvas size to container
        gridElem.width = containerElem.clientWidth;
        gridElem.height = containerElem.clientHeight;

        // Setup unified handlers
        setupCanvasHandlers(gridElem);

        console.log("[Canvas Rendering] Canvas-based UI built. Width:",
          gridElem.width, "Height:", gridElem.height);

        // Render immediately
        renderGrid();
        resolve();
      });
    }

    // 2. Canvas-based rendering for the Game of Life
    function renderGrid() {
      const canvas = document.getElementById("grid");
      if (!canvas || !canvas.getContext) {
        console.warn("[Canvas Rendering] Canvas or context not available.");
        return;
      }
      const ctx = canvas.getContext("2d");

      // Disable anti-aliasing for crisp edges
      ctx.imageSmoothingEnabled = false;
      
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#24283b";  
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Calculate cell size ensuring whole pixels
      const cellWidth = Math.ceil(canvas.width / cols);
      const cellHeight = Math.ceil(canvas.height / rows);

      console.log("[Canvas Rendering] Drawing generation on canvas...");

      // Normal pass: draw alive cells
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c] === 1) {
            ctx.fillStyle = "#88f9d7"; // alive cell color
            // Use integer positions and add 1 to width/height to ensure overlap
            ctx.fillRect(
              Math.floor(c * cellWidth), 
              Math.floor(r * cellHeight), 
              cellWidth + 1, 
              cellHeight + 1
            );
          }
        }
      }

      // Draw hover highlight if we have one
      if (lastHoverCell) {
        highlightHoverRegion(ctx, lastHoverCell.row, lastHoverCell.col, cellWidth, cellHeight);
      }
    }

    // Track animation state
    let hoverAnimationFrame = null;
    let hoverOpacity = 0;
    const HOVER_FADE_SPEED = 0.08;  // Even smoother fade
 
    // Track hover position for smooth transitions
    let currentHoverPos = { x: 0, y: 0 };
    let targetHoverPos = { x: 0, y: 0 };
    let hoverVelocity = { x: 0, y: 0 };  // Add velocity for momentum
    const HOVER_EASE = 0.12;     // Slower easing for smoother movement
    const VELOCITY_DECAY = 0.92; // Slower velocity decay
    const MIN_MOVEMENT = 0.01;   // Lower threshold for smoother finish
    const PREDICTION_WEIGHT = 0.3; // How much to predict future position
    
    // Track mouse movement for prediction
    let lastMousePos = { x: 0, y: 0 };
    let mouseVelocity = { x: 0, y: 0 };
    let lastMoveTime = 0;
    
    // Lerp helper for smooth transitions
    function lerp(start, end, t) {
      // Cubic easing for smoother acceleration/deceleration
      t = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      return start + (end - start) * t;
    }

    // Highlight hovered cell plus neighbors
    function highlightHoverRegion(ctx, centerR, centerC, cellWidth, cellHeight) {
      ctx.save();
      
      // Smoothly animate both opacity and position
      hoverOpacity = Math.min(hoverOpacity + HOVER_FADE_SPEED, 1.0);
      
      // Update position with velocity and easing
      const dx = targetHoverPos.x - currentHoverPos.x;
      const dy = targetHoverPos.y - currentHoverPos.y;
      
      // Predict future position based on mouse velocity
      const predictedX = targetHoverPos.x + mouseVelocity.x * PREDICTION_WEIGHT;
      const predictedY = targetHoverPos.y + mouseVelocity.y * PREDICTION_WEIGHT;
      
      // Apply easing to velocity
      hoverVelocity.x = lerp(hoverVelocity.x, dx + (predictedX - targetHoverPos.x), HOVER_EASE);
      hoverVelocity.y = lerp(hoverVelocity.y, dy + (predictedY - targetHoverPos.y), HOVER_EASE);
      
      // Apply velocity with decay
      currentHoverPos.x += hoverVelocity.x;
      currentHoverPos.y += hoverVelocity.y;
      hoverVelocity.x *= VELOCITY_DECAY;
      hoverVelocity.y *= VELOCITY_DECAY;
      
      // Convert smooth position back to grid coordinates
      const smoothR = Math.floor(currentHoverPos.y / cellHeight);
      const smoothC = Math.floor(currentHoverPos.x / cellWidth);
      
      ctx.globalAlpha = hoverOpacity;

      // Helper to fill a single cell with the correct highlight color
      function fillHighlightedCell(r, c) {
        if (r < 0 || r >= rows || c < 0 || c >= cols) return;
        if (grid[r][c] === 1) {
          ctx.fillStyle = "#9ffae2"; // alive hover
        } else {
          ctx.fillStyle = "#2a2e43"; // dead hover
        }
        
        // Apply subtle scaling effect based on distance from center
        const distX = Math.abs(c - smoothC);
        const distY = Math.abs(r - smoothR);
        const dist = Math.sqrt(distX * distX + distY * distY);
        const scale = 1 - Math.min(dist * 0.1, 0.2); // Subtle scale effect
        
        // Calculate actual render position with scaling
        const centerX = Math.floor(c * cellWidth + cellWidth / 2);
        const centerY = Math.floor(r * cellHeight + cellHeight / 2);
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(scale, scale);
        // Add 1 to dimensions to ensure overlap
        ctx.fillRect(
          -Math.floor(cellWidth/2), 
          -Math.floor(cellHeight/2), 
          cellWidth + 1, 
          cellHeight + 1
        );
        ctx.restore();
      }

      // Draw center cell first
      fillHighlightedCell(smoothR, smoothC);

      // Draw cardinal directions (cross pattern)
      fillHighlightedCell(smoothR - 1, smoothC); // top
      fillHighlightedCell(smoothR, smoothC + 1); // right
      fillHighlightedCell(smoothR + 1, smoothC); // bottom
      fillHighlightedCell(smoothR, smoothC - 1); // left

      ctx.restore();

      // Continue animation if either opacity or position is still transitioning
      const stillMoving = 
        Math.abs(hoverVelocity.x) > MIN_MOVEMENT ||
        Math.abs(hoverVelocity.y) > MIN_MOVEMENT ||
        Math.abs(dx) > MIN_MOVEMENT ||
        Math.abs(dy) > MIN_MOVEMENT;
      
      if (hoverOpacity < 1.0 || stillMoving) {
        hoverAnimationFrame = requestAnimationFrame(() => renderGrid());
      }
    }

    // 3. Setup mouse/touch to handle drag drawing & hover
    function setupCanvasHandlers(canvas) {
      // MOUSE
      canvas.addEventListener("mousedown", (e) => {
        isDrawing = true;
        handlePointer(e.clientX, e.clientY, canvas, /*draw*/true);
      });
      canvas.addEventListener("mousemove", (e) => {
        handlePointer(e.clientX, e.clientY, canvas, isDrawing);
      });
      canvas.addEventListener("mouseup", () => {
        isDrawing = false;
        lastDrawnCell = null;
      });
      canvas.addEventListener("mouseleave", () => {
        isDrawing = false;
        lastDrawnCell = null;
        if (hoverAnimationFrame) {
          cancelAnimationFrame(hoverAnimationFrame);
          hoverAnimationFrame = null;
        }
        lastHoverCell = null;
        hoverOpacity = 0;
        currentHoverPos = { x: 0, y: 0 };
        targetHoverPos = { x: 0, y: 0 };
        mouseVelocity = { x: 0, y: 0 };
        hoverVelocity = { x: 0, y: 0 };
        lastMoveTime = 0;
        renderGrid();
      });

      // TOUCH
      canvas.addEventListener("touchstart", (e) => {
        isDrawing = true;
        const touch = e.touches[0];
        handlePointer(touch.clientX, touch.clientY, canvas, /*draw*/true);
      }, { passive: false });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault(); // prevent scrolling
        if (!isDrawing) return;
        const touch = e.touches[0];
        handlePointer(touch.clientX, touch.clientY, canvas, /*draw*/true);
      }, { passive: false });

      canvas.addEventListener("touchend", () => {
        isDrawing = false;
        lastDrawnCell = null;
      });
      canvas.addEventListener("touchcancel", () => {
        isDrawing = false;
        lastDrawnCell = null;
        if (hoverAnimationFrame) {
          cancelAnimationFrame(hoverAnimationFrame);
          hoverAnimationFrame = null;
        }
        lastHoverCell = null;
        hoverOpacity = 0;
        currentHoverPos = { x: 0, y: 0 };
        targetHoverPos = { x: 0, y: 0 };
        mouseVelocity = { x: 0, y: 0 };
        hoverVelocity = { x: 0, y: 0 };
        lastMoveTime = 0;
        renderGrid();
      });

      console.log("[Canvas Rendering] Canvas event handlers set up.");
    }

    // 4. Convert pointer coordinates => row & col, set hover, optionally create clumps
    function handlePointer(clientX, clientY, canvas, shouldDraw) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      const cellWidth = canvas.width / cols;
      const cellHeight = canvas.height / rows;
      const col = Math.floor(x / cellWidth);
      const row = Math.floor(y / cellHeight);

      // Only handle hover effects on non-touch devices
      if (!isTouchDevice() && (!lastHoverCell || lastHoverCell.row !== row || lastHoverCell.col !== col)) {
        // Cancel any existing hover animation
        if (hoverAnimationFrame) {
          cancelAnimationFrame(hoverAnimationFrame);
          hoverAnimationFrame = null;
        }
        
        // Set target position for smooth transition
        targetHoverPos.x = col * cellWidth;
        targetHoverPos.y = row * cellHeight;
        
        // If this is the first hover, snap immediately
        if (!lastHoverCell) {
          currentHoverPos.x = targetHoverPos.x;
          currentHoverPos.y = targetHoverPos.y;
          hoverVelocity.x = 0;
          hoverVelocity.y = 0;
        }
        
        hoverOpacity = 0;
        lastHoverCell = { row, col };
      }

      // If we should draw random clumps (click/drag)
      if (shouldDraw) {
        const cellKey = `${row},${col}`;
        if (lastDrawnCell !== cellKey) {
          lastDrawnCell = cellKey;
          createClump(row, col);
        }
      }

      // Only re-render if we're drawing or if we're showing hover effects
      if (shouldDraw || !isTouchDevice()) {
        renderGrid();
      }
    }

    // 4. "createClump" remains the same but is now triggered from the canvas handlers:
    function createClump(centerR, centerC) {
      const radius = 2;
      for (let dr = -radius; dr <= radius; dr++) {
        for (let dc = -radius; dc <= radius; dc++) {
          const r = centerR + dr;
          const c = centerC + dc;
          if (r >= 0 && r < rows && c >= 0 && c < cols) {
            const distance = Math.sqrt(dr * dr + dc * dc);
            const probability = 0.8 - (distance / radius) * 0.5;
            grid[r][c] = Math.random() < probability ? 1 : 0;
          }
        }
      }
    }

    // -----------------------------------------------------
    // Game Logic
    // -----------------------------------------------------
    function computeNextGeneration(currentGrid) {
      const newGrid = createEmptyGrid(rows, cols);
      
      // Process cells in chunks for better performance
      const CHUNK_SIZE = 1000;
      const totalCells = rows * cols;
      
      for (let start = 0; start < totalCells; start += CHUNK_SIZE) {
        const end = Math.min(start + CHUNK_SIZE, totalCells);
        
        for (let i = start; i < end; i++) {
          const r = Math.floor(i / cols);
          const c = i % cols;
          const neighbors = countNeighbors(currentGrid, r, c);
          const cellState = currentGrid[r][c];
          
          // Simplified rule checking
          newGrid[r][c] = (neighbors === 3 || (cellState === 1 && neighbors === 2)) ? 1 : 0;
        }
      }
      
      return newGrid;
    }

    function countNeighbors(g, row, col) {
      let count = 0;
      for (let i = 0; i < NEIGHBOR_COUNT * 2; i += 2) {
        const nr = row + NEIGHBOR_OFFSETS[i];
        const nc = col + NEIGHBOR_OFFSETS[i + 1];
        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
          count += g[nr][nc];
        }
      }
      return count;
    }

    function allCellsDead(g) {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] === 1) return false;
        }
      }
      return true;
    }

    // -----------------------------------------------------
    // Pattern Loading
    // -----------------------------------------------------
    function loadPattern(patternName) {
      try {
        if (!patterns[patternName]) return;
        stopGame();
        
        // Clear grid first
        grid = createEmptyGrid(rows, cols);

        // Calculate bounding box of pattern
        const pattern = patterns[patternName];
        let minRow = Infinity, maxRow = -Infinity;
        let minCol = Infinity, maxCol = -Infinity;
        pattern.forEach(([r, c]) => {
          if (r < minRow) minRow = r;
          if (r > maxRow) maxRow = r;
          if (c < minCol) minCol = c;
          if (c > maxCol) maxCol = c;
        });

        const patternHeight = maxRow - minRow + 1;
        const patternWidth = maxCol - minCol + 1;
        const rowOffset = Math.floor(rows / 2 - patternHeight / 2) - minRow;
        const colOffset = Math.floor(cols / 2 - patternWidth / 2) - minCol;

        // Populate the grid
        pattern.forEach(([r, c]) => {
          const newR = r + rowOffset;
          const newC = c + colOffset;
          if (newR >= 0 && newR < rows && newC >= 0 && newC < cols) {
            grid[newR][newC] = 1;
          }
        });

        // Force a full redraw
        renderGrid();

        // Start playing automatically
        startGame();
        document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';
      } catch (error) {
        console.error('Error loading pattern:', error);
        clearGrid();
      }
    }

    // -----------------------------------------------------
    // Controls
    // -----------------------------------------------------
    function startGame() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      
      if (allCellsDead(grid)) {
        randomizeGrid();
      }
      
      playing = true;
      document.getElementById("zoomSelect").disabled = true;
      
      timer = setInterval(() => {
        grid = computeNextGeneration(grid);
        renderGrid();
        FPS.update();
      }, BASE_INTERVAL / currentSpeedMultiplier);
    }

    function stopGame() {
      playing = false;
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>';
      document.getElementById("zoomSelect").disabled = false;
    }

    function toggleGame() {
      if (playing) {
        stopGame();
      } else {
        startGame();
        document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';
      }
    }

    function stepGeneration() {
      stopGame();
      grid = computeNextGeneration(grid);
      renderGrid();
    }

    function randomizeGrid() {
      stopGame();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          grid[r][c] = Math.random() > 0.8 ? 1 : 0;
        }
      }
      renderGrid();
    }

    function clearGrid() {
      stopGame();
      grid = createEmptyGrid(rows, cols);
      renderGrid();
    }

    // Add after other performance optimizations

    const FPS = {
      frames: [],
      lastFrameTimeStamp: performance.now(),
      
      update() {
        const now = performance.now();
        const delta = now - this.lastFrameTimeStamp;
        this.lastFrameTimeStamp = now;
        const fps = 1000 / delta;
        
        this.frames.push(fps);
        if (this.frames.length > 30) {
          this.frames.shift();
        }
      },
      
      getAverageFPS() {
        return this.frames.reduce((a, b) => a + b, 0) / this.frames.length;
      }
    };

    class GameController {
      constructor(gameState) {
        this.state = gameState;
        this.lastFrame = performance.now();
        
        // Constants
        this.NEIGHBOR_OFFSETS = new Int8Array([-1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1]);
        this.NEIGHBOR_COUNT = 8;
        this.CHUNK_SIZE = 1000;
      }

      toggleGame() {
        if (this.state.playing) {
          this.stopGame();
        } else {
          this.startGame();
        }
      }

      startGame() {
        if (this.allCellsDead()) {
          this.randomizeGrid();
        }
        
        this.state.playing = true;
        this.state.lastRenderTime = performance.now();
        
        requestAnimationFrame(() => this.gameLoop());
      }

      gameLoop() {
        if (!this.state.playing) return;
        
        const now = performance.now();
        const elapsed = now - this.state.lastRenderTime;
        
        if (elapsed > this.state.calculateInterval()) {
          this.state.grid = this.computeNextGeneration();
          this.state.updateFPS();
          this.state.lastRenderTime = now;
        }
        
        requestAnimationFrame(() => this.gameLoop());
      }

      // ... other controller methods ...
    }

    class GameUIController {
      constructor(gameController) {
        this.game = gameController;
        this.domElements = {
          grid: document.getElementById('grid'),
          toggleBtn: document.getElementById('toggleBtn'),
          stepBtn: document.getElementById('stepBtn'),
          randomBtn: document.getElementById('randomBtn'),
          clearBtn: document.getElementById('clearBtn'),
          speedSelect: document.getElementById('speedSelect'),
          zoomSelect: document.getElementById('zoomSelect')
        };
      }

      initializeUI() {
        // Setup event listeners
        this.domElements.toggleBtn.addEventListener('click', () => this.game.toggleGame());
        this.domElements.stepBtn.addEventListener('click', () => this.game.stepGeneration());
        this.domElements.randomBtn.addEventListener('click', () => this.game.randomizeGrid());
        this.domElements.clearBtn.addEventListener('click', () => this.game.clearGrid());
        
        this.domElements.speedSelect.addEventListener('change', (e) => {
          this.game.state.setSpeed(parseFloat(e.target.value));
        });

        this.setupPatternButtons();
        this.setupZoomControl();
        this.setupGridInteraction();
      }

      updatePlayButton(playing) {
        this.domElements.toggleBtn.innerHTML = playing ? 
          '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>' :
          '<i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>';
      }

      // ... other UI methods ...
    }

    // Add this after the GameState class and before the existing game logic
    class ComputeEngine {
      constructor() {
        this.wasm = null;
        this.memory = null;
        this.isWasmSupported = false;
      }

      async initialize() {
        // Base64 encoded WebAssembly module implementing Game of Life rules
        const wasmBase64 = `
          AGFzbQEAAAABBwFgA39/fwADAgEABAUBcAEBAQUDAQABBxsCBm1lbW9yeQIAEWNvbXB1dGVfbmV4dF9nZW4AAApvAW0BAX8CQEF/
          IQIDQCABQQFqIQEgAUEBSw0ACyAAQQFqIQAgAEEBSw0ACwJAA0BBACEBAkADQCAAIAEgAhAwIQMgACABIAMQMSABQQFqIQEgAUEB
          Sw0ACyAAQQFqIQAgAEEBSw0ACwtBAAsDAAELCQEAQQALAwABC0MBAX8CQEF/IQIDQCABQQFqIQEgAUEBSw0ACyAAQQFqIQAgAEEB
          Sw0ACwJAA0BBACEBAkADQCAAIAEgAhAwIQMgACABIAMQMSABQQFqIQEgAUEBSw0ACyAAQQFqIQAgAEEBSw0ACwtBAAsL`;

        try {
          if (typeof WebAssembly !== 'undefined' && WebAssembly.validate) {
            // Convert Base64 to Uint8Array
            const binaryString = atob(wasmBase64);
            const uint8Array = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              uint8Array[i] = binaryString.charCodeAt(i);
            }

            // Create memory
            this.memory = new WebAssembly.Memory({ 
              initial: 256  // 16MB initial size
            });

            // Create WASM instance
            const result = await WebAssembly.instantiate(uint8Array, {
              env: {
                memory: this.memory
              }
            });

            this.wasm = result.instance.exports;
            this.isWasmSupported = true;
            console.log('WASM initialization successful');
          }
        } catch (err) {
          console.warn('WASM initialization failed:', err);
          this.isWasmSupported = false;
        }
      }

      computeNextGeneration(currentGrid) {
        if (this.isWasmSupported && this.wasm) {
          try {
            const rows = currentGrid.length;
            const cols = currentGrid[0].length;
            const size = rows * cols;
            
            // Get view of WASM memory
            const view = new Int32Array(this.memory.buffer, 0, size * 2);
            
            // Copy input grid to first half of memory
            let idx = 0;
            for (let i = 0; i < rows; i++) {
              for (let j = 0; j < cols; j++) {
                view[idx++] = currentGrid[i][j];
              }
            }

            // Compute next generation
            this.wasm.compute_next_gen(0, size, rows);
            
            // Copy result from second half of memory
            const newGrid = createEmptyGrid(rows, cols);
            idx = size; // Start from second half
            for (let i = 0; i < rows; i++) {
              for (let j = 0; j < cols; j++) {
                newGrid[i][j] = view[idx++];
              }
            }
            
            return newGrid;
          } catch (err) {
            console.warn('WASM computation failed, falling back to JS:', err);
            return this.computeNextGenerationJS(currentGrid);
          }
        }
        return this.computeNextGenerationJS(currentGrid);
      }

      computeNextGenerationJS(currentGrid) {
        return computeNextGeneration(currentGrid);
      }
    }

    // Initialize compute engine
    const computeEngine = new ComputeEngine();

    // Modify the existing startGame function
    function startGame() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      
      if (allCellsDead(grid)) {
        randomizeGrid();
      }
      
      playing = true;
      document.getElementById("zoomSelect").disabled = true;
      
      // Initialize compute engine if not already done
      if (!computeEngine.initialized) {
        computeEngine.initialize().then(() => {
          computeEngine.initialized = true;
        }).catch(err => {
          console.error('Failed to initialize compute engine:', err);
        });
      }
      
      timer = setInterval(() => {
        grid = computeEngine.computeNextGeneration(grid);
        renderGrid();
        FPS.update();
      }, BASE_INTERVAL / currentSpeedMultiplier);
    }

    // Track current drawing + hover state
    let isDrawing = false;       // Are we currently clicking/dragging?
    let lastHoverCell = null;    // Which cell (row,col) is hovered?
    let lastDrawnCell = null;    // Keep track so we don't re-draw same cell repeatedly

    // Detect mobile or touch devices
    const isTouchDevice = () => {
      return (('ontouchstart' in window) ||
        (navigator.maxTouchPoints > 0) ||
        (navigator.msMaxTouchPoints > 0));
    };
  </script>

  <!-- cite original Tokyo Night reference in markdown, as requested -->
  <p style="display:none;">
    Referenced from [Tokyo Night VSCode Theme](https://github.com/tokyo-night/tokyo-night-vscode-theme)
  </p>

  <!-- Instructions Modal -->
  <div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-game">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="instructionsModalLabel">How it works</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>
            <strong>Select</strong> any area to create clusters of cells, or <strong>select and drag</strong> 
            to draw living paths. Press <strong>Play</strong> to watch your creation evolve, or use <strong>Step Forward</strong> 
            to advance one generation at a time. Use <strong>Randomize</strong> for chaos, 
            or <strong>Clear</strong> to start fresh.
          </p>
          
          <h6>The Rules</h6>
          <p>
            Each cell follows four simple rules in every generation:
            <ul>
              <li><strong>Underpopulation:</strong> A living cell with fewer than 2 neighbors dies</li>
              <li><strong>Survival:</strong> A living cell with 2 or 3 neighbors survives</li>
              <li><strong>Overpopulation:</strong> A living cell with more than 3 neighbors dies</li>
              <li><strong>Reproduction:</strong> A dead cell with exactly 3 neighbors becomes alive</li>
            </ul>
          </p>
          
          <h6>Controls</h6>
          <p>
            <ul>
              <li><strong>Play/Pause:</strong> Start or stop the simulation</li>
              <li><strong>Step Forward:</strong> Advance one generation at a time</li>
              <li><strong>Speed:</strong> Adjust how quickly generations pass</li>
              <li><strong>Zoom:</strong> Change the grid size (only while paused)</li>
            </ul>
          </p>
          
          <h6>Pattern Examples</h6>
          <p class="mb-0">
            Try the preset patterns to see different behaviors:
            <ul class="mb-0">
              <li><strong>Glider:</strong> A pattern that moves diagonally across the grid</li>
              <li><strong>Pulsar:</strong> A large pattern that oscillates with a period of 3 generations</li>
              <li><strong>Small Exploder:</strong> A pattern that expands outward chaotically</li>
            </ul>
          </p>
          
          <p class="mb-large">
            Experiment with different patterns and see how they evolve over time!
          </p>
          
        </div>
      </div>
    </div>
</div>
</body>
</html>