<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4JE9G63Y9Z"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4JE9G63Y9Z');
  </script>
  <meta charset="UTF-8" />
  <title>Wolfram's Rule 110 - Blake Crosley Sandbox</title>
  <!-- Viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Twitter Card data -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@BlakeC">
  <meta name="twitter:creator" content="@BlakeC">
  <meta name="twitter:title" content="Wolfram's Rule 110 - Interactive Simulation">
  <meta name="twitter:description" content="Explore complex behavior arising from a simple set of 1D rules. Toggle cells and watch as Rule 110 patterns evolve.">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/blakecrosley/supahost/main/sandbox/self-assembling-brain/rule110/preview.png">
  <meta name="twitter:image:alt" content="Wolfram's Rule 110 1D automaton simulation showing evolving patterns">
  <meta name="twitter:domain" content="github.blakecrosley.com">
  
  <!-- Open Graph data (also used by other platforms) -->
  <meta property="og:title" content="Wolfram's Rule 110 - Interactive Simulation">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule110/">
  <meta property="og:image" content="https://raw.githubusercontent.com/blakecrosley/supahost/main/sandbox/self-assembling-brain/rule110/preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:description" content="Dive into the fascinating world of elementary cellular automata. Toggle cells and see Rule 110's emergent patterns unfold.">
  <meta property="og:site_name" content="Blake Crosley's Sandbox">

  <!-- Apple Messages Preview -->
  <meta name="apple-mobile-web-app-title" content="Rule 110 Automaton">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule110/preview-icon.png">
  <!-- Apple Messages Link Preview -->
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Apple Messages Fallback -->
  <link rel="mask-icon" href="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule110/preview-icon.png" color="#24283b">

  <!-- Bootstrap 5.3.3 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" 
    rel="stylesheet"
  />

  <!-- Add this after Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <style>
    /* Tokyo Night colors from https://github.com/tokyo-night/tokyo-night-vscode-theme */
    :root {
      --tn-bg: #1a1b26;         /* Primary background */
      --tn-panel: #24283b;      /* Panel/secondary backgrounds */
      --tn-foreground: #c0caf5; /* Main text color */
      --tn-btn-bg: #414868;     /* Button background */
      --tn-btn-bg-hover: #565f89;
      --tn-btn-text: #c0caf5;
      --tn-border: #565f89;
    }

    /* Overall page styling */
    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--tn-bg) !important;
      color: var(--tn-foreground) !important;
      font-size: 20px;
      line-height: 1.4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding-top: 120px;
      padding-bottom: 0px;
    }

    /* Navbar inherits panel color */
    .navbar {
      background-color: rgba(36, 40, 59, 0.8) !important;
      border-bottom: 1px solid var(--tn-border);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Buttons */
    .btn-secondary {
      background-color: var(--tn-btn-bg) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      border-color: var(--tn-border) !important;
    }

    .btn-outline-secondary {
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-outline-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }

    /* Form Controls (like .form-select) */
    .form-select {
      background-color: var(--tn-panel) !important;
      color: var(--tn-foreground) !important;
      border-color: var(--tn-border) !important;
    }
    .form-select:focus {
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(108,117,125,.5);
    }

    /* Grid container for Rule 110 canvas */
    #grid-container {
      margin: 0 auto;
      border: 1px solid var(--tn-border);
      border-radius: .5rem;
      background: var(--tn-panel);
      box-sizing: border-box;
      width: 100%;
      position: relative;
      padding-bottom: 60%; /* Match aspect ratio from similar examples */
      overflow: hidden;
      cursor: pointer;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #gridWrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* We'll render our 1D automaton rows on this canvas */
    #grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--tn-border);
      display: block;
      image-rendering: pixelated; /* Crisp cell rendering */
    }

    /* Control sections */
    #rule110Controls {
      margin-bottom: 16px;
    }
    #zoomControls {
      margin: 16px 0;
    }

    /* Headings */
    h1, h2, h3, h4, h5, h6  {
      margin-top: 0em;
      margin-bottom: .5em;
      color: rgb(245, 133, 237);
      font-weight: bold;
    }

    /* Link styling */
    a.instructions-link {
      color: rgb(245, 133, 237);
      text-decoration: underline;
      transition: all 0.2s ease;
    }
    a.instructions-link:hover {
      color: rgb(250, 164, 244);
      text-decoration: underline;
      text-underline-offset: 4px;
    }
    a.instructions-link:active {
      color: rgb(219, 119, 212);
    }

    p {
      margin-bottom: 1em;
    }
    p.mb-large {
      margin-bottom: 3em;
    }

    /* Code showcase styling (background, etc.) */
    .code-showcase {
      background: #1a1b26;
      border-radius: .5rem;
      margin: 1rem 0 3rem 0;
      border: 1px solid var(--tn-border);
    }
    .code-showcase pre {
      background: #24283b;
      padding: 1.5rem;
      border-radius: .5rem;
      overflow-x: auto;
      margin: 0;
      font-family: 'Poppins', sans-serif;
      font-size: 18px;
      line-height: 1.6;
    }
    .code-showcase code {
      color: #88f9d7;
      text-shadow: none;
      background: none;
      font-family: 'Poppins', sans-serif;
    }
    .code-showcase p {
      color: #88f9d7;
      margin: 1em 0;
      padding: 0 1.5rem;
    }

    .footer {
      background-color: var(--tn-panel);
      border-top: 1px solid var(--tn-border);
      position: relative;
      bottom: 0;
      width: 100%;
      padding: 1rem 0;
    }
    
    .text-muted {
      color: var(--tn-foreground) !important;
      opacity: 0.7;
    }

    .footer-links a {
      color: var(--tn-foreground);
      opacity: 0.7;
      text-decoration: none;
      margin: 0.5rem;
      transition: opacity 0.2s ease;
    }
    .footer-links a:hover {
      opacity: 1;
    }

    .footer-links {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .footer-social {
      display: flex;
      gap: 1.5rem;
    }

    @media (max-width: 768px) {
      .footer {
        margin: 0;
        padding: 1rem 0;
      }
      .footer .container {
        padding: 0;
        margin: 0;
        max-width: 100%;
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      .footer-links {
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }
      .footer-social {
        justify-content: center;
        margin: 0.5rem 0;
      }
      .footer-links a {
        margin: 0.5rem;
      }
    }

    /* Navbar toggler */
    @media (max-width: 991.98px) {
      .navbar .navbar-collapse {
        padding: 1rem 0;
      }
      .navbar .navbar-nav {
        gap: 0.5rem;
      }
      .navbar .btn {
        width: 100%;
        margin: 0 !important;
      }
    }
    .navbar-toggler {
      border-color: var(--tn-border);
      padding: 0.25rem 0.5rem;
    }
    .navbar-toggler:focus {
      box-shadow: none;
      border-color: var(--tn-foreground);
    }
    .navbar-toggler .bi-list {
      font-size: 1.5rem;
    }

    /* Loading overlay */
    #loadingState {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--tn-panel);
      border-radius: .5rem;
      z-index: 10;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 1rem;
    }
    .spinner {
      width: 3rem;
      height: 3rem;
      border: 0.25rem solid var(--tn-border);
      border-top-color: var(--tn-foreground);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>

  <link rel="icon" type="image/png" href="../../../favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="../../../favicon/favicon.svg" />
  <link rel="shortcut icon" href="../../../favicon/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png" />
  <link rel="manifest" href="../../../favicon/site.webmanifest" />

</head>

<body>
  <!-- Bootstrap 5 Navbar -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a href="https://x.com/BlakeC" class="navbar-brand text-decoration-none" target="_blank">
        <img src="../../../assets/profile.jpg" 
             alt="@blakec" 
             class="rounded-circle me-2" 
             style="width: 32px; height: 32px;">
        @blakec
      </a>
      
      <!-- Hamburger button for mobile -->
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" 
              data-bs-target="#navbarContent" aria-controls="navbarContent" 
              aria-expanded="false" aria-label="Toggle navigation">
        <i class="bi bi-list text-light"></i>
      </button>
      
      <!-- Collapsible content -->
      <div class="collapse navbar-collapse" id="navbarContent">
        <div class="navbar-nav ms-auto">
          <a href="https://blakecrosley.com" class="btn btn-outline-secondary me-2" target="_blank">
            blakecrosley.com
          </a>
          <a href="https://941apps.com" class="btn btn-outline-secondary" target="_blank">
            941apps.com
          </a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Main container: Use a Bootstrap container and row -->
  <div class="container-fluid">
    <div class="row">
      <!-- 8 columns wide on large screens, 12 on smaller, with offset for center -->
      <div class="col-12 col-lg-8 offset-lg-2">
        
        <!-- BEGIN Rule 110 functionality section -->
        <div class="row" id="rule110Controls">
          <div class="col-12 d-flex flex-wrap align-items-center justify-content-between">
            <h1>Wolfram's Rule 110</h1>

            <!-- Editorial description -->
            <div id="description">
              <p>
                Wolfram's Rule 110 is a remarkable one-dimensional cellular automaton from Stephen Wolfram's 
                classification of "elementary" rules. Each cell in this linear grid can be in one of two 
                states: 0 (off) or 1 (on). With every step, the next row of cells is determined by looking at 
                triples in the current row—each cell plus its two neighbors. The pattern of which triples 
                produce a 1 in the next generation is encoded by the binary number <strong>110</strong>.
              </p>
              <p>
                Despite its simple definition—just a handful of bits describing which local arrangements 
                become "on"—Rule 110 exhibits incredibly rich and complex behavior. It's even been proven to be 
                Turing-complete under certain initial conditions, placing it on par with systems that can, 
                in theory, perform universal computation. In other words, something as minimal as a row of 
                zeroes and ones can support the full scope of computable operations if seeded correctly.
              </p>
              <p class="mb-large">
                <a href="#" class="instructions-link" data-bs-toggle="modal" data-bs-target="#instructionsModal">
                  How it works
                </a>
              </p>
            </div>

            <!-- Button group -->
            <div class="btn-group btn-group-lg" role="group" aria-label="Rule 110 controls">
              <button id="toggleBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>
              </button>
              <button id="stepBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-skip-end"></i> <span class="d-none d-sm-inline">Step Forward</span>
              </button>
              <button id="randomBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-dice-6"></i> <span class="d-none d-sm-inline">Randomize</span>
              </button>
              <button id="clearBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-x-circle"></i> <span class="d-none d-sm-inline">Clear</span>
              </button>
            </div>
            <!-- Speed select -->
            <div class="ms-3 d-inline-flex align-items-center">
              <label for="speedSelect" class="form-label me-2 mb-0">Speed</label>
              <select id="speedSelect" class="form-select form-select-lg d-inline-block" style="width:auto;">
                <option value="0.5">0.5×</option>
                <option value="1" selected>1×</option>
                <option value="2">2×</option>
                <option value="4">4×</option>
                <option value="8">8×</option>
                <option value="16">16×</option>
              </select>
            </div>
          </div>
        </div>

        <!-- The grid container for Rule 110 rendering -->
        <div id="grid-container">
          <div id="loadingState">
            <div class="spinner"></div>
            <div>Loading Rule 110 board...</div>
          </div>
          <div id="gridWrapper">
            <!-- We'll use a <canvas> for 1D rows, each new generation appended below -->
            <canvas id="grid"></canvas>
          </div>
        </div>

        <!-- Zoom controls -->
        <div class="d-flex justify-content-end align-items-center" id="zoomControls">
          <label for="zoomSelect" class="form-label me-2 mb-0">Zoom</label>
          <select id="zoomSelect" class="form-select form-select-lg d-inline-block" style="width:auto;">
            <option value="1" selected>1×</option>
            <option value="2">2×</option>
            <option value="3">3×</option>
          </select>
        </div>

        <h3>The Rule</h3>
        <p>
          In Rule 110, we look at each group of three adjacent cells: left, center, and right. This triplet 
          decides the center cell's state in the next generation. Because each cell is either 0 or 1, 
          there are only eight possible triplets (from 000 to 111). The "110" in the name refers to the 
          binary digits that define which of those triplets produce a 1 in the next row.
        </p>
        
        <p>
          The rule can be expressed as a lookup table, where each three-cell pattern maps to the next state:
        </p>
        
        <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Rule 110 transition table - maps each 3-bit pattern to its next state</span>
<span style="color: #bb9af7;">const</span> <span style="color: #7aa2f7;">transitions</span> = {
  <span style="color: #565f89;">// pattern => next state</span>
  <span style="color: #9aa5ce;">'111'</span>: <span style="color: #ff9e64;">0</span>,
  <span style="color: #9aa5ce;">'110'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'101'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'100'</span>: <span style="color: #ff9e64;">0</span>,
  <span style="color: #9aa5ce;">'011'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'010'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'001'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'000'</span>: <span style="color: #ff9e64;">0</span>
};
</code></pre>

        <p>
          Each new generation is drawn below the previous one, creating a cascading visual of patterns. 
          Some configurations settle into repetitive structures, while others spawn chaotic or 
          <em>almost</em> orderly ripples that hint at deeper complexity.
        </p>

        <h3>Emergence &amp; Complexity</h3>
        <p>
          One of the most intriguing aspects of Rule 110 is how a single row of bits can give rise 
          to structures that look like moving particles or collisions. Tiny changes in the initial row 
          can completely alter the unfolding tapestry. This emergent complexity arises purely from the 
          local rule applied over and over—no central coordination is needed.
        </p>
        <p>
          Researchers have studied this automaton extensively to understand how 
          simple deterministic systems might exhibit patterns that appear random, or at least 
          computationally irreducible. In many initial conditions, you'll see wavefronts, stable 
          regions, and "gliders" that mimic the concept of moving entities within the grid of bits.
        </p>

        <h3>Turing Completeness &amp; Universal Computation</h3>
        <p>
          Rule 110's claim to fame is that it can be configured to compute anything a universal Turing 
          machine can, making it <strong>Turing-complete</strong>. In simpler terms, if you can set up 
          the initial row just right, the evolving rows can emulate logical operations, memory, and 
          other fundamental computing elements. 
        </p>
        <p>
          This is a profound reminder that complexity doesn't require complexity in the rules 
          themselves—it's the repeated interactions over time that yield remarkable computational 
          power. It also underscores the deep ties between cellular automata and the foundations of 
          theoretical computer science.
        </p>

        <h3>Why Should We Care?</h3>
        <p>
          Beyond its theoretical significance, Rule 110 demonstrates that profound behavior can emerge 
          from tiny building blocks governed by straightforward laws. This resonates with many fields 
          of science and engineering where complex phenomena unfold from local interactions: from 
          traffic flow and biological growth to parallel computing and cryptography.
        </p>
        <p>
          In practical terms, studying such elementary cellular automata helps sharpen our intuition 
          about how complexity arises, how patterns self-organize, and how minimal systems can encode 
          far more than meets the eye at first glance. It's a playground for discovering how the seeds 
          of computation can be hidden in the humblest of setups.
        </p>

        <h3>The Algorithm</h3>
        <p>
          Below is a simplified version of how we compute one new row from another. We can handle boundary 
          cells by assuming they're 0 outside the edges, or by wrapping around. For simplicity, let's assume 
          edges have 0 neighbors:
        </p>
        
        <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">computeNextRow</span>(<span style="color: #e0af68;">currentRow</span>) {
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">length</span> = <span style="color: #e0af68;">currentRow</span>.length;
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">newRow</span> = <span style="color: #c0caf5;">new</span> <span style="color: #73daca;">Array</span>(length).fill(<span style="color: #ff9e64;">0</span>);
  
  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> i = <span style="color: #ff9e64;">0</span>; i < length; i++) {
    <span style="color: #565f89;">// Use 0 for cells outside boundaries</span>
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">left</span> = (i === <span style="color: #ff9e64;">0</span>) ? <span style="color: #ff9e64;">0</span> : currentRow[i - <span style="color: #ff9e64;">1</span>];
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">center</span> = currentRow[i];
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">right</span> = (i === length - <span style="color: #ff9e64;">1</span>) ? <span style="color: #ff9e64;">0</span> : currentRow[i + <span style="color: #ff9e64;">1</span>];
    
    <span style="color: #565f89;">// Create 3-bit pattern (0-7)</span>
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">pattern</span> = (left << <span style="color: #ff9e64;">2</span>) | (center << <span style="color: #ff9e64;">1</span>) | right;
    
    <span style="color: #565f89;">// Apply Rule 110 transition function</span>
    <span style="color: #7dcfff;">newRow</span>[i] = (<span style="color: #ff9e64;">110</span> >> pattern) & <span style="color: #ff9e64;">1</span>;
  }
  <span style="color: #bb9af7;">return</span> newRow;
}
</code></pre>

        <p style="color: #c0caf5; margin: 1rem 0 3rem 0;">
          By stitching these rows together vertically on our canvas, we get a live visual of how patterns 
          emerge from a minimal set of rules. Tiny differences in the first row can lead to drastically 
          different evolutions, showcasing how large-scale complexity can surface from local interactions.
        </p>
        <!-- END Rule 110 functionality section -->
  
      </div>
    </div>
  </div>
  
  <!-- Footer -->
  <div class="container-fluid footer-container">
    <div class="row">
      <footer class="footer mt-auto">
        <div class="container d-flex justify-content-between align-items-center mw-100">
          <span class="text-muted">© 2025</span>
          <div class="footer-links">
            <div class="">
              <a href="https://x.com/BlakeC" target="_blank" title="X (Twitter)">
                <i class="bi bi-twitter-x"></i>
              </a>
              <a href="https://github.com/blakecrosley" target="_blank" title="GitHub">
                <i class="bi bi-github"></i>
              </a>
            </div>
            <a href="https://blakecrosley.com" target="_blank" title="Personal Website">
              blakecrosley.com
            </a>
            <a href="https://941apps.com" target="_blank" title="941 Apps">
              941apps.com
            </a>
          </div>
        </div>
      </footer>
    </div>
  </div>
  <!-- Bootstrap 5.3.3 JS (includes Popper) -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous">
  </script>

  <!-- Main Rule 110 Script (Vanilla JS) -->
  <script>
    // We'll structure this similarly to the Conway example, but adapted for Rule 110's 1D nature.
    // We'll draw multiple generations on a single canvas, each generation is a row of cells.
    // The user can toggle the first row by clicking, then watch the pattern unfold.

    class Rule110State {
      constructor() {
        this.baseCols = 60;         // Base number of columns at zoom level 1
        this.maxRows = 300;         // Max history rows
        this.currentSpeedMultiplier = 1.0;
        this.baseInterval = 50;     // 50ms => 20 steps/s at speed=1
        this.playing = false;
        this.timer = null;
        this.zoom = 1;
        this.generations = [];
        this.canvas = document.getElementById("grid");
        this.ctx = this.canvas.getContext("2d");
        this.isDrawing = false;
        this.cols = this.baseCols;  // Will be updated based on zoom
        this.rowsDrawn = 0;
      }

      calculateInterval() {
        return this.baseInterval / this.currentSpeedMultiplier;
      }

      updateInterval() {
        if (this.playing && this.timer) {
          clearInterval(this.timer);
          this.timer = setInterval(() => {
            stepGeneration();
          }, this.calculateInterval());
        }
      }
    }

    // Our global state
    const R110 = new Rule110State();

    // ------------- MAIN DOMContentLoaded SETUP -------------
    document.addEventListener("DOMContentLoaded", () => {
      calculateCanvasSize();
      createInitialGeneration();
      renderAllGenerations();
      setupControls();

      // Hook up controls
      document.getElementById("toggleBtn").addEventListener("click", toggleGame);
      document.getElementById("stepBtn").addEventListener("click", stepGeneration);
      document.getElementById("randomBtn").addEventListener("click", randomizeFirstRow);
      document.getElementById("clearBtn").addEventListener("click", clearAll);

      document.getElementById("zoomSelect").addEventListener("change", (e) => {
        if (!R110.playing) {
          setZoom(parseFloat(e.target.value));
        } else {
          alert("Pause the simulation before changing zoom.");
          e.target.value = R110.zoom; // revert
        }
      });

      // Setup canvas pointer for toggling the first row
      setupCanvasPointer(R110.canvas);
    });

    // ------------- CANVAS & DIMENSIONS -------------
    function calculateCanvasSize() {
      const containerElem = document.getElementById("grid-container");
      const containerWidth = containerElem.clientWidth;
      const containerHeight = containerElem.clientHeight;
      
      // Set canvas to container size
      R110.canvas.width = containerWidth;
      R110.canvas.height = containerHeight;
      
      // Calculate cells based on zoom level
      R110.cols = R110.baseCols * R110.zoom;
      R110.cellSize = containerWidth / R110.cols;
      
      // Safely limit total rows
      R110.maxRows = Math.min(Math.floor(containerHeight / R110.cellSize), 300);
    }

    async function setZoom(zoomValue) {
      showLoading();
      try {
        // Save old first row
        const oldFirstRow = R110.generations.length > 0 ? R110.generations[0].slice() : null;

        // Reset everything
        R110.zoom = zoomValue;
        R110.generations = [];
        R110.rowsDrawn = 0;
        clearCanvas();
        
        // Recalc canvas size
        calculateCanvasSize();

        // Rebuild first row
        if (oldFirstRow) {
          const newRow = new Array(R110.cols).fill(0);
          const offset = Math.floor((R110.cols - oldFirstRow.length) / 2);
          for (let i = 0; i < oldFirstRow.length; i++) {
            const idx = i + offset;
            if (idx >= 0 && idx < R110.cols) {
              newRow[idx] = oldFirstRow[i];
            }
          }
          R110.generations.push(newRow);
        } else {
          createInitialGeneration();
        }

        renderAllGenerations();
        hideLoading();
      } catch (err) {
        console.error("Zoom error:", err);
        hideLoading();
      }
    }

    function clearCanvas() {
      R110.ctx.clearRect(0, 0, R110.canvas.width, R110.canvas.height);
      R110.ctx.fillStyle = "#24283b";
      R110.ctx.fillRect(0, 0, R110.canvas.width, R110.canvas.height);
    }

    // ------------- STATE & GENERATION LOGIC -------------
    function createInitialGeneration() {
      const row = new Array(R110.cols).fill(0);
      // Provide a small starting pattern or random partial fill
      if (R110.zoom === 1) {
        row[Math.floor(R110.cols * 0.1)] = 1;
      } else {
        for (let i = 0; i < R110.cols; i++) {
          if (Math.random() < 0.1) row[i] = 1;
        }
      }
      R110.generations.push(row);
      R110.rowsDrawn = 0;
    }

    function stepGeneration() {
      if (R110.generations.length === 0) {
        createInitialGeneration();
      }
      const lastRow = R110.generations[R110.generations.length - 1];
      const newRow = computeNextRow(lastRow);
      R110.generations.push(newRow);
      renderNewRow(newRow, R110.generations.length - 1);
    }

    function computeNextRow(currentRow) {
      const length = currentRow.length;
      const newRow = new Array(length).fill(0);
      
      for (let i = 0; i < length; i++) {
        const left = (i === 0) ? 0 : currentRow[i - 1];
        const center = currentRow[i];
        const right = (i === length - 1) ? 0 : currentRow[i + 1];
        const pattern = (left << 2) | (center << 1) | right;
        newRow[i] = (110 >> pattern) & 1;
      }
      return newRow;
    }

    function randomizeFirstRow() {
      stopGame();
      R110.generations = [];
      const row = new Array(R110.cols).fill(0);
      const density = 0.1 * R110.zoom;  // Slightly more at higher zoom
      for (let i = 0; i < R110.cols; i++) {
        if (Math.random() < density) row[i] = 1;
      }
      R110.generations.push(row);
      R110.rowsDrawn = 0;
      clearCanvas();
      renderAllGenerations();
    }

    function clearAll() {
      stopGame();
      R110.generations = [];
      R110.rowsDrawn = 0;
      clearCanvas();
      createInitialGeneration();
      renderAllGenerations();
    }

    // ------------- RENDERING -------------
    function renderAllGenerations() {
      clearCanvas();
      for (let rowIndex = 0; rowIndex < R110.generations.length; rowIndex++) {
        const rowData = R110.generations[rowIndex];
        renderNewRow(rowData, rowIndex);
      }
    }

    function renderNewRow(rowData, rowIndex) {
      const ctx = R110.ctx;
      const cellSize = R110.cellSize;

      ctx.save();
      ctx.imageSmoothingEnabled = false;
      ctx.fillStyle = "#7aa2f7";  // Active cell color
      
      for (let c = 0; c < rowData.length; c++) {
        if (rowData[c] === 1) {
          const x = c * cellSize;
          const y = rowIndex * cellSize;
          ctx.fillRect(x, y, cellSize, cellSize);
        }
      }
      ctx.restore();
    }

    // ------------- POINTER: Toggle first row -------------
    function setupCanvasPointer(canvas) {
      canvas.addEventListener("mousedown", (e) => {
        R110.isDrawing = true;
        toggleCellAtPointer(e);
      });
      canvas.addEventListener("mousemove", (e) => {
        if (R110.isDrawing) toggleCellAtPointer(e);
      });
      canvas.addEventListener("mouseup", () => {
        R110.isDrawing = false;
      });
      canvas.addEventListener("mouseleave", () => {
        R110.isDrawing = false;
      });

      canvas.addEventListener("touchstart", (e) => {
        R110.isDrawing = true;
        toggleCellAtPointer(e.touches[0]);
      }, { passive: false });
      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (R110.isDrawing) toggleCellAtPointer(e.touches[0]);
      }, { passive: false });
      canvas.addEventListener("touchend", () => {
        R110.isDrawing = false;
      });
      canvas.addEventListener("touchcancel", () => {
        R110.isDrawing = false;
      });
    }

    function toggleCellAtPointer(evt) {
      if (!R110.generations.length) return;
      const rect = R110.canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      // Only toggle if pointer is within the first row's vertical span
      // which is from y=0 to y=cellSize
      if (y > R110.cellSize) {
        return;
      }

      const col = Math.floor(x / R110.cellSize);
      if (col < 0 || col >= R110.cols) return;

      const firstRow = R110.generations[0];
      firstRow[col] = firstRow[col] ? 0 : 1;
      renderNewRow(firstRow, 0);
    }

    // ------------- PLAY / STOP / TIMER -------------
    function toggleGame() {
      if (R110.playing) {
        stopGame();
      } else {
        startGame();
      }
    }

    function startGame() {
      if (R110.timer) {
        clearInterval(R110.timer);
        R110.timer = null;
      }
      R110.playing = true;
      document.getElementById("zoomSelect").disabled = true;
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';

      R110.timer = setInterval(() => {
        stepGeneration();
      }, R110.calculateInterval());
    }

    function stopGame() {
      R110.playing = false;
      if (R110.timer) {
        clearInterval(R110.timer);
        R110.timer = null;
      }
      document.getElementById("zoomSelect").disabled = false;
      document.getElementById("toggleBtn").innerHTML = '<i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>';
    }

    // ------------- LOADING OVERLAY -------------
    function showLoading() {
      const loadingState = document.getElementById("loadingState");
      loadingState.style.display = "flex";
    }
    function hideLoading() {
      const loadingState = document.getElementById("loadingState");
      loadingState.style.display = "none";
    }

    // ------------- Setup Additional Controls -------------
    function setupControls() {
      document.getElementById("speedSelect").addEventListener("change", (e) => {
        const val = parseFloat(e.target.value);
        R110.currentSpeedMultiplier = val;
        R110.updateInterval();
      });
    }
  </script>

  <!-- cite original Tokyo Night reference in markdown, as requested -->
  <p style="display:none;">
    Referenced from [Tokyo Night VSCode Theme](https://github.com/tokyo-night/tokyo-night-vscode-theme)
  </p>

  <!-- Instructions Modal -->
  <div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-game">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="instructionsModalLabel">How it works</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>
            <strong>Toggle</strong> cells in the initial row by clicking (or tapping) near the top. Press <strong>Play</strong> 
            to watch Rule 110 generate new rows at the bottom of the canvas. Each step applies the "110" 
            rule to every cell, determining if it remains off or lights up based on its neighbors.
          </p>
          
          <h6>The Rules</h6>
          <p>
            If you look at the three adjacent cells in the current row—left, center, right—the next state of 
            the center cell is found by checking whether those three bits match a pattern that yields a 1 
            (on) or 0 (off) under the "110" mapping:
            <ul>
              <li><strong>111 → 0</strong></li>
              <li><strong>110 → 1</strong></li>
              <li><strong>101 → 1</strong></li>
              <li><strong>100 → 0</strong></li>
              <li><strong>011 → 1</strong></li>
              <li><strong>010 → 1</strong></li>
              <li><strong>001 → 1</strong></li>
              <li><strong>000 → 0</strong></li>
            </ul>
          </p>
          
          <h6>Controls</h6>
          <p>
            <ul>
              <li><strong>Play/Pause:</strong> Start or stop the generation of new rows</li>
              <li><strong>Step Forward:</strong> Generate exactly one new row</li>
              <li><strong>Randomize:</strong> Fill the initial row with random 0/1 cells</li>
              <li><strong>Clear:</strong> Reset the canvas to a blank row of all zeros</li>
              <li><strong>Speed:</strong> Adjust how quickly new rows appear in auto-play mode</li>
              <li><strong>Zoom:</strong> Change how many cells (and row height) appear (only while paused)</li>
            </ul>
          </p>
          
          <p class="mb-0">
            Experiment by toggling patterns in the first row or using random seeds to watch how quickly 
            complexity emerges!
          </p>
        </div>
      </div>
    </div>
  </div>
</body>
</html>