<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4JE9G63Y9Z"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-4JE9G63Y9Z');
  </script>
  <meta charset="UTF-8" />
  <title>Wolfram's Rule 110 - Blake Crosley Sandbox</title>
  <!-- Viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Twitter Card data -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@BlakeC">
  <meta name="twitter:creator" content="@BlakeC">
  <meta name="twitter:title" content="Wolfram's Rule 110 - Interactive Simulation">
  <meta name="twitter:description" content="Explore complex behavior arising from a simple set of 1D rules. Toggle cells and watch as Rule 110 patterns evolve.">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/blakecrosley/supahost/main/sandbox/self-assembling-brain/rule-110/preview.png">
  <meta name="twitter:image:alt" content="Wolfram's Rule 110 1D automaton simulation showing evolving patterns">
  <meta name="twitter:domain" content="github.blakecrosley.com">
  
  <!-- Open Graph data -->
  <meta property="og:title" content="Wolfram's Rule 110 - Interactive Simulation">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule-110/">
  <meta property="og:image" content="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule-110/preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:description" content="Dive into the fascinating world of elementary cellular automata. Toggle cells and see Rule 110's emergent patterns unfold.">
  <meta property="og:site_name" content="Blake Crosley's Sandbox">

  <!-- Apple Messages Preview -->
  <meta name="apple-mobile-web-app-title" content="Rule 110 Automaton">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule-110/preview-icon.png">

  <!-- Apple Messages Link Preview -->
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Apple Messages Fallback -->
  <link rel="mask-icon" href="https://github.blakecrosley.com/sandbox/self-assembling-brain/rule-110/preview-icon.png" color="#24283b">

  <!-- Bootstrap 5.3.3 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />

  <!-- Google Fonts: Poppins -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" 
    rel="stylesheet"
  />

  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <style>
    /* Tokyo Night colors from https://github.com/tokyo-night/tokyo-night-vscode-theme */
    :root {
      --tn-bg: #1a1b26;         /* Primary background */
      --tn-panel: #24283b;      /* Panel/secondary backgrounds */
      --tn-foreground: #c0caf5; /* Main text color */
      --tn-btn-bg: #414868;     /* Button background */
      --tn-btn-bg-hover: #565f89;
      --tn-btn-text: #c0caf5;
      --tn-border: #565f89;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--tn-bg) !important;
      color: var(--tn-foreground) !important;
      font-size: 20px;
      line-height: 1.4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding-top: 120px;
      padding-bottom: 0px;
    }

    .navbar {
      background-color: rgba(36, 40, 59, 0.8) !important;
      border-bottom: 1px solid var(--tn-border);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .btn-secondary {
      background-color: var(--tn-btn-bg) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      border-color: var(--tn-border) !important;
    }

    .btn-outline-secondary {
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }
    .btn-outline-secondary:hover {
      background-color: var(--tn-btn-bg-hover) !important;
      color: var(--tn-btn-text) !important;
      border-color: var(--tn-border) !important;
    }

    .form-select {
      background-color: var(--tn-panel) !important;
      color: var(--tn-foreground) !important;
      border-color: var(--tn-border) !important;
    }
    .form-select:focus {
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(108,117,125,.5);
    }
    .form-select:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    #grid-container {
      margin: 0 auto;
      border: 1px solid var(--tn-border);
      border-radius: .5rem;
      background: var(--tn-panel);
      box-sizing: border-box;
      width: 100%;
      position: relative;
      padding-bottom: 60%;
      overflow: hidden;
      cursor: pointer;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #gridWrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Main render canvas */
    #grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--tn-border);
      display: block;
      image-rendering: pixelated;
    }

    /* Hover highlight overlay canvas */
    #hoverCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* allow clicks to pass through to #grid */
    }

    #rule110Controls {
      margin-bottom: 16px;
    }
    #zoomControls {
      margin: 16px 0 3em 0;
    }

    h1, h2, h3, h4, h5, h6  {
      margin-top: 0em;
      margin-bottom: .5em;
      color: rgb(245, 133, 237);
      font-weight: bold;
    }

    a.instructions-link {
      color: rgb(245, 133, 237);
      text-decoration: underline;
      transition: all 0.2s ease;
    }
    a.instructions-link:hover {
      color: rgb(250, 164, 244);
      text-decoration: underline;
      text-underline-offset: 4px;
    }
    a.instructions-link:active {
      color: rgb(219, 119, 212);
    }

    p {
      margin-bottom: 1em;
    }
    p.mb-large {
      margin-bottom: 3em;
    }

    .code-showcase {
      background: #1a1b26;
      border-radius: .5rem;
      margin: 1rem 0 3rem 0;
      border: 1px solid var(--tn-border);
    }
    .code-showcase pre {
      background: #24283b;
      padding: 1.5rem;
      border-radius: .5rem;
      overflow-x: auto;
      margin: 0;
      font-family: 'Poppins', sans-serif;
      font-size: 18px;
      line-height: 1.6;
    }
    .code-showcase code {
      color: #88f9d7;
      text-shadow: none;
      background: none;
      font-family: 'Poppins', sans-serif;
    }
    .code-showcase p {
      color: #88f9d7;
      margin: 1em 0;
      padding: 0 1.5rem;
    }

    .footer {
      background-color: var(--tn-panel);
      border-top: 1px solid var(--tn-border);
      position: relative;
      bottom: 0;
      width: 100%;
      padding: 1rem 0;
    }
    .text-muted {
      color: var(--tn-foreground) !important;
      opacity: 0.7;
    }

    .footer-links a {
      color: var(--tn-foreground);
      opacity: 0.7;
      text-decoration: none;
      margin: 0.5rem;
      transition: opacity 0.2s ease;
    }
    .footer-links a:hover {
      opacity: 1;
    }
    .footer-links {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .footer-social {
      display: flex;
      gap: 1.5rem;
    }

    @media (max-width: 768px) {
      .footer {
        margin: 0;
        padding: 1rem 0;
      }
      .footer .container {
        padding: 0;
        margin: 0;
        max-width: 100%;
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      .footer-links {
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }
      .footer-social {
        justify-content: center;
        margin: 0.5rem 0;
      }
      .footer-links a {
        margin: 0.5rem;
      }
    }

    @media (max-width: 991.98px) {
      .navbar .navbar-collapse {
        padding: 1rem 0;
      }
      .navbar .navbar-nav {
        gap: 0.5rem;
      }
      .navbar .btn {
        width: 100%;
        margin: 0 !important;
      }
    }
    .navbar-toggler {
      border-color: var(--tn-border);
      padding: 0.25rem 0.5rem;
    }
    .navbar-toggler:focus {
      box-shadow: none;
      border-color: var(--tn-foreground);
    }
    .navbar-toggler .bi-list {
      font-size: 1.5rem;
    }

    #loadingState {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--tn-panel);
      border-radius: .5rem;
      z-index: 10;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 1rem;
    }
    .spinner {
      width: 3rem;
      height: 3rem;
      border: 0.25rem solid var(--tn-border);
      border-top-color: var(--tn-foreground);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .form-check-input {
      background-color: var(--tn-panel) !important;
      border-color: var(--tn-border) !important;
    }

    .form-check-input:checked {
      background-color: var(--tn-btn-bg) !important;
      border-color: var(--tn-btn-bg) !important;
    }

    .form-check-input:focus {
      border-color: var(--tn-border);
      box-shadow: 0 0 0 0.2rem rgba(65, 72, 104, 0.25);
    }

    .form-switch .form-check-input {
      height: 1.275em;
      width: 2.5em;
      cursor: pointer;
      margin-top: 0.15em; /* Better vertical alignment with label */
    }

    /* Improve layout of the wrap edges control */
    .form-check.form-switch {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin: 0;
      padding: 0;
      flex-direction: row-reverse;
      justify-content: flex-start;
    }

    .form-check-input {
      margin-left: 0 !important;
      margin-right: 0 !important;
    }

    .form-check-label {
      margin-right: 12px;
    }

    /* Update the form-check-label style */
    #zoomControls .form-check-label {
      margin-right: 0;
    }

    /* Add this to style the toggle circle */
    .form-switch .form-check-input:checked::before {
      background-color: #c0caf5 !important;
    }

    /* Update the toggle circle color to match our theme's light blue */
    .form-switch .form-check-input:checked {
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23c0caf5'/%3e%3c/svg%3e") !important;
    }
  </style>

  <link rel="icon" type="image/png" href="../../../favicon/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="../../../favicon/favicon.svg" />
  <link rel="shortcut icon" href="../../../favicon/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="../../../favicon/apple-touch-icon.png" />
  <link rel="manifest" href="../../../favicon/site.webmanifest" />
</head>

<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container-fluid">
      <a href="https://x.com/BlakeC" class="navbar-brand text-decoration-none" target="_blank">
        <img src="../../../assets/profile.jpg" 
             alt="@blakec" 
             class="rounded-circle me-2" 
             style="width: 32px; height: 32px;">
        @blakec
      </a>
      
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" 
              data-bs-target="#navbarContent" aria-controls="navbarContent" 
              aria-expanded="false" aria-label="Toggle navigation">
        <i class="bi bi-list text-light"></i>
      </button>
      
      <div class="collapse navbar-collapse" id="navbarContent">
        <div class="navbar-nav ms-auto">
          <a href="https://blakecrosley.com" class="btn btn-outline-secondary me-2" target="_blank">
            blakecrosley.com
          </a>
          <a href="https://941apps.com" class="btn btn-outline-secondary" target="_blank">
            941apps.com
          </a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Main container -->
  <div class="container-fluid">
    <div class="row">
      <div class="col-12 col-lg-8 offset-lg-2">
        
        <!-- Title & Controls Row -->
        <div class="row" id="rule110Controls">
          <div class="col-12 d-flex flex-wrap align-items-center justify-content-between">
            <h1>Wolfram's Rule 110</h1>
            <button type="button" class="btn btn-secondary" data-bs-toggle="modal" data-bs-target="#instructionsModal">
              <i class="bi bi-question-circle"></i> <span class="d-none d-sm-inline">How it works</span>
            </button>
            <div id="description">
              <p>
                Wolfram's Rule 110 is a remarkable one-dimensional cellular automaton from Stephen Wolfram's 
                classification of "elementary" rules. Each cell in this linear grid can be in one of two 
                states: 0 (off) or 1 (on). With every step, the next row of cells is determined by looking at 
                triples in the current row—each cell plus its two neighbors. The pattern of which triplets 
                produce a 1 in the next generation is encoded by the binary number <strong>110</strong>.
              </p>
              <p>
                Despite its minimal definition—just a handful of bits describing which local arrangements 
                become "on"—Rule 110 demonstrates incredibly rich and complex behavior. It's even been proven 
                to be Turing-complete under certain initial conditions, placing it on par with systems that 
                can, in theory, perform universal computation.
              </p>
              <p class="mb-large">
                <a href="#" class="instructions-link" data-bs-toggle="modal" data-bs-target="#instructionsModal">
                  How it works
                </a>
              </p>
            </div>

            <!-- Button group -->
            <div class="btn-group btn-group-lg" role="group" aria-label="Rule 110 controls">
              <button id="toggleBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>
              </button>
              <button id="stepBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-skip-end"></i> <span class="d-none d-sm-inline">Step Forward</span>
              </button>
              <button id="randomBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-dice-6"></i> <span class="d-none d-sm-inline">Randomize</span>
              </button>
              <button id="clearBtn" type="button" class="btn btn-secondary">
                <i class="bi bi-x-circle"></i> <span class="d-none d-sm-inline">Clear</span>
              </button>
            </div>

            <!-- Speed -->
            <div class="d-flex align-items-center gap-2">
              <label for="speedSelect" class="form-label  mb-0">Speed</label>
              <select class="form-select form-select-lg" id="speedSelect">
                <option value="0.5">0.5×</option>
                <option value="1" selected>1×</option>
                <option value="2">2×</option>
                <option value="4">4×</option>
                <option value="8">8×</option>
                <option value="16">16×</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Grid container -->
        <div id="grid-container">
          <div id="loadingState">
            <div class="spinner"></div>
            <div>Loading Rule 110 board...</div>
          </div>
          <div id="gridWrapper">
            <!-- Main rendering canvas -->
            <canvas id="grid"></canvas>
            <!-- Hover highlight overlay canvas -->
            <canvas id="hoverCanvas"></canvas>
          </div>
        </div>

        <!-- Wrap Edges + Zoom Controls -->
        <div id="zoomControls" class="d-flex justify-content-between align-items-center"> 
          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" role="switch" id="wrapEdgesToggle" checked>
            <label class="form-check-label" for="wrapEdgesToggle">
              Wrap Edges
            </label>
          </div>
          <div class="d-flex align-items-center gap-3">
            <label for="zoomSelect" class="form-label mb-0">Zoom</label>
            <select class="form-select form-select-lg" id="zoomSelect" style="width: auto;">
              <option value="1">1×</option>
              <option value="2">2×</option>
              <option value="4">4×</option>
              <option value="8">8×</option>
              <option value="16">16×</option>
            </select>
          </div>
        </div>

        <h3>The Rule</h3>
        <p>
          In elementary cellular automaton terminology, the decimal rule number 110 corresponds to the bit pattern 
          01101110 when read from the '111' triplet down to '000.' That means certain triplets (like 110, 101, 011, 001) 
          yield a live cell in the next generation, while others result in a dead cell.
        </p>
        <p class="mb-large">
          Despite the straightforward naming convention, the behaviors that emerge can be surprisingly complex. You'll 
          see chaotic regions, repetitive patterns, and all manner of interactions driven by these simple triplet rules.
        </p>

        <h3>Emergence &amp; Complexity</h3>
        <p>
          One of the most intriguing aspects of Rule 110 is how a single row of bits can evolve into 
          structures that look like moving particles, collisions, or wavefronts. Tiny changes in the initial 
          row can drastically alter the unfolding tapestry, highlighting the system's sensitivity to initial conditions. 
          This emergent complexity arises purely from local interactions—no central coordination is required.
        </p>
        <p class="mb-large">
          In certain configurations, you'll witness stable regions, "gliders," and repeating or chaotic expansions that 
          underscore the system's depth. Researchers have studied this automaton extensively to understand how simple 
          deterministic systems might exhibit patterns that appear random or are at least computationally irreducible.
        </p>

        <h3>Turing Completeness</h3>
        <p class="mb-large">
          Rule 110 can be configured to compute anything a universal Turing machine can, making it Turing-complete. That 
          means if you set up the initial row in just the right way, you can theoretically emulate logical operations, 
          memory, and any fundamental computing element within this small automaton. It's a striking demonstration 
          that complexity can arise from even the simplest set of rules—it's the repeated local interactions over 
          time that yield powerful behavior.
        </p>

        <h3>Algorithmic Overview</h3>
        <p class="mb-large">
          Below is a straightforward approach to computing each new row. We optionally wrap edges so cells on one side 
          can see neighbors on the opposite side. If this is disabled, edges are considered "dead" beyond the grid:
        </p>

        <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #565f89;">// Rule 110 transition table - maps each 3-bit pattern to its next state</span>
<span style="color: #bb9af7;">const</span> <span style="color: #7aa2f7;">transitions</span> = {
  <span style="color: #565f89;">// pattern => next state</span>
  <span style="color: #9aa5ce;">'111'</span>: <span style="color: #ff9e64;">0</span>,
  <span style="color: #9aa5ce;">'110'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'101'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'100'</span>: <span style="color: #ff9e64;">0</span>,
  <span style="color: #9aa5ce;">'011'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'010'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'001'</span>: <span style="color: #ff9e64;">1</span>,
  <span style="color: #9aa5ce;">'000'</span>: <span style="color: #ff9e64;">0</span>
};
</code></pre>

        <p>
          And here's how we apply it during each update (although our final implementation uses the shift 
          approach, this table is an alternate expression of which triplets yield a live cell):
        </p>
        
        <pre style="background: #24283b; padding: 1.5rem; border-radius: .5rem; margin-top: 1rem; margin-bottom: 3rem; overflow-x: auto; border: 1px solid var(--tn-border);"><code>
<span style="color: #bb9af7;">function</span> <span style="color: #7aa2f7;">computeNextRow</span>(<span style="color: #e0af68;">currentRow</span>, <span style="color: #e0af68;">wrapEdges</span>) {
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">length</span> = <span style="color: #e0af68;">currentRow</span>.length;
  <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">newRow</span> = <span style="color: #c0caf5;">new</span> <span style="color: #73daca;">Array</span>(length).fill(<span style="color: #ff9e64;">0</span>);

  <span style="color: #bb9af7;">for</span> (<span style="color: #bb9af7;">let</span> i = <span style="color: #ff9e64;">0</span>; i < length; i++) {
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">leftIndex</span>  = <span style="color: #e0af68;">wrapEdges</span> ? (i - <span style="color: #ff9e64;">1</span> + length) % length : i - <span style="color: #ff9e64;">1</span>;
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">rightIndex</span> = <span style="color: #e0af68;">wrapEdges</span> ? (i + <span style="color: #ff9e64;">1</span>) % length : i + <span style="color: #ff9e64;">1</span>;

    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">left</span>   = (leftIndex < <span style="color: #ff9e64;">0</span> || leftIndex >= length) ? <span style="color: #ff9e64;">0</span> : <span style="color: #e0af68;">currentRow</span>[leftIndex];
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">center</span> = <span style="color: #e0af68;">currentRow</span>[i];
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">right</span>  = (rightIndex < <span style="color: #ff9e64;">0</span> || rightIndex >= length) ? <span style="color: #ff9e64;">0</span> : <span style="color: #e0af68;">currentRow</span>[rightIndex];
    
    <span style="color: #c0caf5;">const</span> <span style="color: #7dcfff;">pattern</span> = (left << 2) | (center << 1) | right;
    newRow[i] = (<span style="color: #ff9e64;">110</span> >> <span style="color: #7dcfff;">pattern</span>) & <span style="color: #ff9e64;">1</span>;
  }
  <span style="color: #bb9af7;">return</span> <span style="color: #7dcfff;">newRow</span>;
}
</code></pre>
      </div>
    </div>
  </div>
  
  <!-- Link to Rule 110 -->
  <div class="text-center mb-5">
    <a href="../conways-game-of-life/" class="btn btn-lg" style="
      background: transparent;
      border: 2px solid rgb(245, 133, 237);
      color: rgb(245, 133, 237);
      transition: all 0.2s ease;
      font-weight: 600;
      padding: 0.75rem 1.5rem;
      " onmouseover="this.style.background='rgba(245, 133, 237, 0.1)';this.style.borderColor='rgb(250, 164, 244)';this.style.color='rgb(250, 164, 244)'" 
      onmouseout="this.style.background='transparent';this.style.borderColor='rgb(245, 133, 237)';this.style.color='rgb(245, 133, 237)'"
      onmousedown="this.style.background='rgba(245, 133, 237, 0.2)';this.style.borderColor='rgb(219, 119, 212)';this.style.color='rgb(219, 119, 212)'"
      onmouseup="this.style.background='rgba(245, 133, 237, 0.1)';this.style.borderColor='rgb(250, 164, 244)';this.style.color='rgb(250, 164, 244)'"
    >
      View Conway's Game of Life →
    </a>
  </div>

  <!-- Footer -->
  <div class="container-fluid footer-container">
    <div class="row">
      <footer class="footer mt-auto">
        <div class="container d-flex justify-content-between align-items-center mw-100">
          <span class="text-muted">© 2025</span>
          <div class="footer-links">
            <div>
              <a href="https://x.com/BlakeC" target="_blank" title="X (Twitter)">
                <i class="bi bi-twitter-x"></i>
              </a>
              <a href="https://github.com/blakecrosley" target="_blank" title="GitHub">
                <i class="bi bi-github"></i>
              </a>
            </div>
            <a href="https://blakecrosley.com" target="_blank" title="Personal Website">
              blakecrosley.com
            </a>
            <a href="https://941apps.com" target="_blank" title="941 Apps">
              941apps.com
            </a>
          </div>
        </div>
      </footer>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script 
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" 
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" 
    crossorigin="anonymous">
  </script>

  <!-- Main Rule 110 Script -->
  <script>
    const speedMap = {
      '0.5': 1000,
      '1': 250,
      '2': 100,
      '4': 16,
      '8': 4,
      '16': 1
    };

    class Rule110State {
      constructor() {
        this.baseCols = 60;    
        this.maxRows = 300;
        this.useWrap = true;
        this.playing = false;
        this.timer = null;

        const speedSelect = document.getElementById("speedSelect");
        this.currentSpeedMultiplier = speedSelect ? parseFloat(speedSelect.value) : 1.0;
        this.baseInterval = 500;  
        this.zoom = 1;
        this.generations = [];

        // Our canvases
        this.canvas = document.getElementById("grid");
        this.ctx = this.canvas.getContext("2d");
        this.hoverCanvas = document.getElementById("hoverCanvas");
        this.hoverCtx = this.hoverCanvas.getContext("2d");

        this.isDrawing = false;
        this.lastToggledCol = -1;
        this.activeFades = {};

        this.cols = this.baseCols;
        this.rowsDrawn = 0;
      }

      calculateInterval() {
        return this.baseInterval / Math.pow(this.currentSpeedMultiplier, 2);
      }

      updateInterval() {
        if (this.playing && this.timer) {
          clearInterval(this.timer);
          this.timer = setInterval(() => stepGeneration(), this.calculateInterval());
        }
      }
    }

    const R110 = new Rule110State();

    document.addEventListener("DOMContentLoaded", () => {
      calculateCanvasSize();
      createInitialGeneration();
      renderAllGenerations();
      setupControls();

      document.getElementById("toggleBtn").addEventListener("click", toggleGame);
      document.getElementById("stepBtn").addEventListener("click", stepGeneration);
      document.getElementById("randomBtn").addEventListener("click", randomizeFirstRow);
      document.getElementById("clearBtn").addEventListener("click", clearAll);

      document.getElementById("wrapEdgesToggle").addEventListener("change", e => {
        R110.useWrap = e.target.checked;
      });

      document.getElementById("zoomSelect").addEventListener("change", (e) => {
        if (!R110.playing) {
          setZoom(parseFloat(e.target.value));
        } else {
          alert("Pause before changing zoom.");
          e.target.value = R110.zoom;
        }
      });

      setupCanvasPointer(R110.canvas);
      setupHoverHighlight(R110.canvas);
    });

    /**
     * If zoom=4,8,16 => fill container width but do the special 
     * rounding approach in getCellRect so there's no gap on last col.
     * Otherwise, fractional approach for 1×,2× etc.
     */
    function calculateCanvasSize() {
      const container = document.getElementById("grid-container");
      const cw = container.clientWidth;
      const ch = container.clientHeight;

      R110.cols = R110.baseCols * R110.zoom;

      if (R110.zoom === 4 || R110.zoom === 8 || R110.zoom === 16) {
        R110.cellSize = cw / R110.cols;
        R110.canvas.width = cw;
        R110.canvas.style.width = "100%";
      } else {
        R110.cellSize = cw / R110.cols;
        R110.canvas.width = cw;
        R110.canvas.style.width = "100%";
      }

      R110.canvas.height = ch;
      R110.canvas.style.height = "100%";

      R110.hoverCanvas.width = R110.canvas.width;
      R110.hoverCanvas.height = R110.canvas.height;
      R110.hoverCanvas.style.width = R110.canvas.style.width;
      R110.hoverCanvas.style.height = R110.canvas.style.height;

      R110.maxRows = Math.floor(ch / R110.cellSize);
    }

    async function setZoom(z) {
      showLoading();
      try {
        const oldRow = R110.generations.length ? [...R110.generations[0]] : null;
        R110.zoom = z;
        R110.generations = [];
        R110.rowsDrawn = 0;
        clearCanvas();

        calculateCanvasSize();

        if (oldRow) {
          const newRow = new Array(R110.cols);
          if (R110.useWrap) {
            for (let i=0; i<R110.cols; i++) {
              newRow[i] = oldRow[i % oldRow.length];
            }
          } else {
            newRow.fill(0);
            const offset = Math.floor((R110.cols - oldRow.length)/2);
            for (let i=0; i<oldRow.length; i++) {
              const idx = i+offset;
              if (idx>=0 && idx<R110.cols) {
                newRow[idx] = oldRow[i];
              }
            }
          }
          R110.generations.push(newRow);
        } else {
          createInitialGeneration();
        }

        renderAllGenerations();
      } catch(err) {
        console.error("Zoom error:", err);
      } finally {
        hideLoading();
      }
    }

    function createInitialGeneration() {
      const row = new Array(R110.cols).fill(0);
      R110.generations.push(row);
      R110.rowsDrawn = 0;
    }

    function stepGeneration() {
      if (!R110.generations.length) {
        createInitialGeneration();
      }
      const last = R110.generations[R110.generations.length-1];
      if (last.some(c=>c===1) && R110.generations.length < R110.maxRows) {
        const next = computeNextRow(last, R110.useWrap);
        R110.generations.push(next);
        renderNewRow(next, R110.generations.length-1);
      }
    }

    function computeNextRow(arr, wrap) {
      const length= arr.length;
      const newArr= new Array(length).fill(0);
      for(let i=0; i<length; i++){
        const leftIndex= i-1;
        const left= leftIndex<0 ? (wrap ? arr[length-1]:0): arr[leftIndex];
        const center= arr[i];
        const rightIndex= i+1;
        const right= rightIndex>=length? (wrap?arr[0]:0): arr[rightIndex];

        const pattern= (left<<2)|(center<<1)| right;
        newArr[i]= (110>> pattern)&1;
      }
      return newArr;
    }

    function randomizeFirstRow() {
      stopGame();
      R110.generations=[];
      R110.rowsDrawn=0;
      const row= new Array(R110.cols).fill(0);

      const baseDensity=0.06;
      const density= Math.min(baseDensity*(1+Math.log2(R110.zoom)*0.1),0.15);
      const cellsToFill= Math.floor(R110.cols*density);
      const positions=[...Array(R110.cols).keys()];
      for(let i=positions.length-1; i>0; i--){
        const j= Math.floor(Math.random()*(i+1));
        [positions[i], positions[j]]=[positions[j], positions[i]];
      }
      for(let i=0;i<cellsToFill;i++){
        row[positions[i]]=1;
      }
      R110.generations.push(row);
      clearCanvas();
      renderAllGenerations();
    }

    function clearAll() {
      stopGame();
      R110.generations=[];
      R110.rowsDrawn=0;
      clearCanvas();
      createInitialGeneration();
      renderAllGenerations();
    }

    /**
     * If zoom=4,8,16 => we do the rounding approach:
     *   col -> x1= round(col*cellSize), x2= round((col+1)*cellSize)
     *   if col is last => x2= canvas.width
     * else crisp approach for others.
     */
    function getCellRect(col,row){
      const x1= col* R110.cellSize;
      const y1= row* R110.cellSize;

      if(R110.zoom===4 || R110.zoom===8 || R110.zoom===16){
        let ix1= Math.round(x1);
        let iy1= Math.round(y1);
        let ix2= Math.round((col+1)* R110.cellSize);
        let iy2= Math.round((row+1)* R110.cellSize);

        if(col=== R110.cols-1){
          ix2= R110.canvas.width;
        }
        return [ix1, iy1, ix2- ix1, iy2- iy1];
      } else {
        const ix= Math.floor(x1);
        const iy= Math.floor(y1);
        const w= Math.ceil(R110.cellSize+1);
        const h= Math.ceil(R110.cellSize+1);
        return [ix, iy, w, h];
      }
    }

    function drawCell(col,row,color,ctx){
      const [x,y,w,h]= getCellRect(col,row);
      ctx.clearRect(x,y,w,h);
      ctx.fillStyle=color;
      ctx.fillRect(x,y,w,h);
    }

    function renderAllGenerations(){
      clearCanvas();
      for(let i=0;i<R110.generations.length;i++){
        renderNewRow(R110.generations[i], i);
      }
    }

    function renderNewRow(rowData,rowIndex){
      for(let c=0;c< rowData.length;c++){
        if(rowData[c]===1){
          drawCell(c,rowIndex,"#88f9d7",R110.ctx);
        }
      }
    }

    function clearCanvas(){
      R110.ctx.clearRect(0,0,R110.canvas.width,R110.canvas.height);
      R110.ctx.fillStyle="#24283b";
      R110.ctx.fillRect(0,0,R110.canvas.width,R110.canvas.height);

      R110.hoverCtx.clearRect(0,0,R110.hoverCanvas.width,R110.hoverCanvas.height);
    }

    function setupCanvasPointer(canvas){
      canvas.addEventListener("mousedown", e=>{
        R110.isDrawing=true;
        R110.lastToggledCol=-1;
        toggleCellAtPointer(e);
      });
      canvas.addEventListener("mousemove", e=>{
        if(R110.isDrawing) toggleCellAtPointer(e);
      });
      canvas.addEventListener("mouseup", ()=>{
        R110.isDrawing=false;
        R110.lastToggledCol=-1;
      });
      canvas.addEventListener("mouseleave", ()=>{
        R110.isDrawing=false;
        R110.lastToggledCol=-1;
      });
      // Touch
      canvas.addEventListener("touchstart", e=>{
        R110.isDrawing=true;
        R110.lastToggledCol=-1;
        toggleCellAtPointer(e.touches[0]);
      },{passive:false});
      canvas.addEventListener("touchmove", e=>{
        e.preventDefault();
        if(R110.isDrawing && e.touches[0]){
          toggleCellAtPointer(e.touches[0]);
        }
      },{passive:false});
      canvas.addEventListener("touchend", ()=>{
        R110.isDrawing=false;
        R110.lastToggledCol=-1;
      });
      canvas.addEventListener("touchcancel", ()=>{
        R110.isDrawing=false;
        R110.lastToggledCol=-1;
      });
    }

    function toggleCellAtPointer(evt){
      if(!R110.generations.length)return;
      const rect= R110.canvas.getBoundingClientRect();
      const x= evt.clientX- rect.left;
      const col= Math.floor(x/R110.cellSize);
      if(col<0||col>= R110.cols)return;
      if(col=== R110.lastToggledCol)return;

      R110.lastToggledCol= col;
      const firstRow= R110.generations[0];
      const oldVal= firstRow[col];
      const newVal= oldVal?0:1;
      firstRow[col]= newVal;

      R110.generations=[firstRow];
      R110.rowsDrawn=0;
      clearCanvas();
      renderNewRow(firstRow,0);

      animateFadeCell(col,oldVal,newVal);
    }

    function animateFadeCell(col,oldVal,newVal){
      if(R110.activeFades[col]){
        R110.activeFades[col].finalizeFn();
        cancelAnimationFrame(R110.activeFades[col].handle);
        delete R110.activeFades[col];
      }
      const startColor= oldVal?"#88f9d7":"#24283b";
      const endColor= newVal?"#88f9d7":"#24283b";
      const startTime= performance.now();
      const duration= 200;
      let done=false;
      let animFrameId=null;

      function finalize(){
        drawCell(col,0,endColor,R110.ctx);
        done=true;
      }
      function frame(now){
        if(done)return;
        const elapsed= now- startTime;
        const t= Math.min(1, elapsed/duration);

        const [r1,g1,b1]= hexToRGB(startColor);
        const [r2,g2,b2]= hexToRGB(endColor);
        const r=Math.round(r1+(r2-r1)*t);
        const g=Math.round(g1+(g2-g1)*t);
        const b=Math.round(b1+(b2-b1)*t);

        drawCell(col,0,`rgb(${r},${g},${b})`,R110.ctx);

        if(elapsed<duration){
          animFrameId=requestAnimationFrame(frame);
        } else {
          finalize();
          delete R110.activeFades[col];
        }
      }
      R110.activeFades[col]={handle:0, finalizeFn: finalize};
      animFrameId=requestAnimationFrame(frame);
      R110.activeFades[col].handle=animFrameId;
    }

    function hexToRGB(hexStr){
      const r=parseInt(hexStr.slice(1,3),16);
      const g=parseInt(hexStr.slice(3,5),16);
      const b=parseInt(hexStr.slice(5,7),16);
      return [r,g,b];
    }

    function setupHoverHighlight(canvas){
      canvas.addEventListener("mousemove", e=>{
        if(R110.playing)return;
        const rect=canvas.getBoundingClientRect();
        const x=e.clientX-rect.left;
        const col=Math.floor(x/R110.cellSize);

        if(col!==R110.hoveredCol){
          R110.hoveredCol=col;
          drawHoverColumn(col);
        }
      });
      canvas.addEventListener("mouseleave",()=>{
        if(R110.playing)return;
        R110.hoveredCol=-1;
        R110.hoverCtx.clearRect(0,0,R110.hoverCanvas.width,R110.hoverCanvas.height);
      });
    }

    function drawHoverColumn(col){
      if(col<0||col>=R110.cols){
        R110.hoverCtx.clearRect(0,0,R110.hoverCanvas.width,R110.hoverCanvas.height);
        return;
      }
      R110.hoverCtx.clearRect(0,0,R110.hoverCanvas.width,R110.hoverCanvas.height);
      R110.hoverCtx.save();
      R110.hoverCtx.fillStyle="rgba(136,249,215,0.15)";
      const xPos=col*R110.cellSize;
      R110.hoverCtx.fillRect(xPos,0,R110.cellSize,R110.hoverCanvas.height);
      R110.hoverCtx.restore();
    }

    function toggleGame(){
      if(R110.playing){
        stopGame();
      } else {
        startGame();
      }
    }

    function startGame(){
      if(R110.timer){
        clearInterval(R110.timer);
      }
      R110.playing=true;
      document.getElementById("zoomSelect").disabled=true;
      document.getElementById("toggleBtn").innerHTML=
        '<i class="bi bi-pause"></i> <span class="d-none d-sm-inline">Pause</span>';

      // Hide hover while playing
      R110.hoveredCol=-1;
      R110.hoverCtx.clearRect(0,0,R110.hoverCanvas.width,R110.hoverCanvas.height);
      R110.hoverCanvas.style.display='none';
      document.getElementById("grid-container").style.cursor='not-allowed';

      // If the first row is empty, fill it with a random pattern
      if(!R110.generations.length || R110.generations[0].every(c=>c===0)){
        const row=new Array(R110.cols).fill(0);
        const baseDensity=0.06;
        const density=Math.min(baseDensity*(1+Math.log2(R110.zoom)*0.1),0.15);
        const cellsToFill= Math.floor(R110.cols*density);
        const positions=[...Array(R110.cols).keys()];
        for(let i=positions.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [positions[i],positions[j]]=[positions[j],positions[i]];
        }
        for(let i=0;i<cellsToFill;i++){
          row[positions[i]]=1;
        }
        R110.generations=[row];
        R110.rowsDrawn=0;
        renderAllGenerations();
      }
      R110.timer=setInterval(stepGeneration,R110.calculateInterval());
    }

    function stopGame(){
      R110.playing=false;
      if(R110.timer){
        clearInterval(R110.timer);
        R110.timer=null;
      }
      document.getElementById("zoomSelect").disabled=false;
      document.getElementById("toggleBtn").innerHTML=
        '<i class="bi bi-play"></i> <span class="d-none d-sm-inline">Play</span>';
      
      // Show hover again
      R110.hoverCanvas.style.display='block';
      document.getElementById("grid-container").style.cursor='pointer';
    }

    function showLoading(){
      const loadingState=document.getElementById("loadingState");
      loadingState.style.display='flex';
    }
    function hideLoading(){
      const loadingState=document.getElementById("loadingState");
      loadingState.style.display='none';
    }

    function setupControls(){
      document.getElementById("speedSelect").addEventListener("change",e=>{
        R110.currentSpeedMultiplier=parseFloat(e.target.value);
        R110.updateInterval();
      });
    }
  </script>

  <!-- cite original Tokyo Night reference in markdown, as requested -->
  <p style="display:none;">
    Referenced from [Tokyo Night VSCode Theme](https://github.com/tokyo-night/tokyo-night-vscode-theme)
  </p>

  <!-- Instructions Modal -->
  <div class="modal fade" id="instructionsModal" tabindex="-1" aria-labelledby="instructionsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-game">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="instructionsModalLabel">How it works</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>
            <strong>Toggle</strong> cells in the top row by clicking and dragging (or tapping and swiping) along the canvas.
            If the first row is left entirely blank, pressing <strong>Play</strong> will automatically seed it with 
            a random pattern. Otherwise, each time you press <strong>Play</strong> or <strong>Step Forward</strong>,
            the "110" rule is applied to generate new rows at the bottom.
          </p>
          
          <h6>The Rules</h6>
          <p>
            For any cell in the current row, look at it plus its left and right neighbors to form a 3-bit pattern. 
            According to Rule 110, these patterns produce the following outcomes:
            <ul>
              <li><strong>111 → 0</strong></li>
              <li><strong>110 → 1</strong></li>
              <li><strong>101 → 1</strong></li>
              <li><strong>100 → 0</strong></li>
              <li><strong>011 → 1</strong></li>
              <li><strong>010 → 1</strong></li>
              <li><strong>001 → 1</strong></li>
              <li><strong>000 → 0</strong></li>
            </ul>
          </p>
          
          <h6>Controls</h6>
          <p>
            <ul>
              <li><strong>Play/Pause:</strong> Runs or stops automatic generation of new rows.</li>
              <li><strong>Step Forward:</strong> Manually computes the next row once.</li>
              <li><strong>Randomize:</strong> Randomly seeds the top row with 1s and 0s.</li>
              <li><strong>Clear:</strong> Resets the entire grid to a single empty row.</li>
              <li><strong>Speed:</strong> Adjusts how fast rows are generated (0.5× ⇒ slower, 16× ⇒ very fast).</li>
              <li><strong>Zoom:</strong> Changes how many cells fit in each row (only available when paused).</li>
              <li><strong>Wrap Edges:</strong> Decides whether cells on the far left/right see each other as neighbors.</li>
            </ul>
          </p>
          
          <p class="mb-0">
            Experiment with toggles or random seeds to see how quickly complex patterns emerge!
          </p>
        </div>
      </div>
    </div>
  </div>
</body>
</html>